// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * Фундаментальные показатели по активу
 */
export const zGetAssetFundamentalsResponseStatisticResponse = z.object({
    assetUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Идентификатор актива.',
        }),
    ),
    currency: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Валюта.',
        }),
    ),
    marketCapitalization: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рыночная капитализация.',
        }),
    ),
    highPriceLast52Weeks: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Максимум за год.',
        }),
    ),
    lowPriceLast52Weeks: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Минимум за год.',
        }),
    ),
    averageDailyVolumeLast10Days: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Средний объем торгов за 10 дней.',
        }),
    ),
    averageDailyVolumeLast4Weeks: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Средний объем торгов за месяц.',
        }),
    ),
    beta: z.optional(z.number()),
    freeFloat: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Доля акций в свободном обращении.',
        }),
    ),
    forwardAnnualDividendYield: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Процент форвардной дивидендной доходности по отношению к цене акций.',
        }),
    ),
    sharesOutstanding: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Количество акций в обращении.',
        }),
    ),
    revenueTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Выручка.',
        }),
    ),
    ebitdaTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'EBITDA — прибыль до вычета процентов, налогов, износа и амортизации.',
        }),
    ),
    netIncomeTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Чистая прибыль.',
        }),
    ),
    epsTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description:
                'EPS — величина чистой прибыли компании, которая приходится на каждую обыкновенную акцию.',
        }),
    ),
    dilutedEpsTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description:
                'EPS компании с допущением, что все конвертируемые ценные бумаги компании были сконвертированы в обыкновенные акции.',
        }),
    ),
    freeCashFlowTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Свободный денежный поток.',
        }),
    ),
    fiveYearAnnualRevenueGrowthRate: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Среднегодовой  рocт выручки за 5 лет.',
        }),
    ),
    threeYearAnnualRevenueGrowthRate: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Среднегодовой  рocт выручки за 3 года.',
        }),
    ),
    peRatioTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Соотношение рыночной капитализации компании к ее чистой прибыли.',
        }),
    ),
    priceToSalesTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Соотношение рыночной капитализации компании к ее выручке.',
        }),
    ),
    priceToBookTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Соотношение рыночной капитализации компании к ее балансовой стоимости.',
        }),
    ),
    priceToFreeCashFlowTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description:
                'Соотношение рыночной капитализации компании к ее свободному денежному потоку.',
        }),
    ),
    totalEnterpriseValueMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рыночная стоимость компании.',
        }),
    ),
    evToEbitdaMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Соотношение EV и EBITDA.',
        }),
    ),
    netMarginMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Маржа чистой прибыли.',
        }),
    ),
    netInterestMarginMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рентабельность чистой прибыли.',
        }),
    ),
    roe: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рентабельность собственного капитала.',
        }),
    ),
    roa: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рентабельность активов.',
        }),
    ),
    roic: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рентабельность активов.',
        }),
    ),
    totalDebtMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Сумма краткосрочных и долгосрочных обязательств компании.',
        }),
    ),
    totalDebtToEquityMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Соотношение долга к собственному капиталу.',
        }),
    ),
    totalDebtToEbitdaMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Total Debt/EBITDA.',
        }),
    ),
    freeCashFlowToPrice: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Отношение свободногоо кэша к стоимости.',
        }),
    ),
    netDebtToEbitda: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Отношение чистого долга к EBITDA.',
        }),
    ),
    currentRatioMrq: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Коэффициент текущей ликвидности.',
        }),
    ),
    fixedChargeCoverageRatioFy: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Коэффициент покрытия фиксированных платежей — FCCR.',
        }),
    ),
    dividendYieldDailyTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Дивидендная доходность за 12 месяцев.',
        }),
    ),
    dividendRateTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Выплаченные дивиденды за 12 месяцев.',
        }),
    ),
    dividendsPerShare: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Значение дивидендов на акцию.',
        }),
    ),
    fiveYearsAverageDividendYield: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Средняя дивидендная доходность за 5 лет.',
        }),
    ),
    fiveYearAnnualDividendGrowthRate: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Среднегодовой рост дивидендов за 5 лет.',
        }),
    ),
    dividendPayoutRatioFy: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Процент чистой прибыли, уходящий на выплату дивидендов.',
        }),
    ),
    buyBackTtm: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Деньги, потраченные на обратный выкуп акций.',
        }),
    ),
    oneYearAnnualRevenueGrowthRate: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Рост выручки за 1 год.',
        }),
    ),
    domicileIndicatorCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код страны.',
        }),
    ),
    adrToCommonShareRatio: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Соотношение депозитарной расписки к акциям.',
        }),
    ),
    numberOfEmployees: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Количество сотрудников.',
        }),
    ),
    exDividendDate: z.optional(z.iso.datetime()),
    fiscalPeriodStartDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало фискального периода.',
        }),
    ),
    fiscalPeriodEndDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Окончание фискального периода.',
        }),
    ),
    revenueChangeFiveYears: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Изменение общего дохода за 5 лет.',
        }),
    ),
    epsChangeFiveYears: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Изменение EPS за 5 лет.',
        }),
    ),
    ebitdaChangeFiveYears: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Изменение EBIDTA за 5 лет.',
        }),
    ),
    totalDebtChangeFiveYears: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Изменение общей задолжности за 5 лет.',
        }),
    ),
    evToSales: z.optional(
        z.number().register(z.globalRegistry, {
            description: 'Отношение EV к выручке.',
        }),
    ),
});

/**
 *  - PERIOD_TYPE_UNSPECIFIED: Не указан.
 * - PERIOD_TYPE_QUARTER: Квартальный.
 * - PERIOD_TYPE_SEMIANNUAL: Полугодовой.
 * - PERIOD_TYPE_ANNUAL: Годовой.
 */
export const zGetAssetReportsResponseAssetReportPeriodType = z
    .enum([
        'PERIOD_TYPE_UNSPECIFIED',
        'PERIOD_TYPE_QUARTER',
        'PERIOD_TYPE_SEMIANNUAL',
        'PERIOD_TYPE_ANNUAL',
    ])
    .register(z.globalRegistry, {
        description:
            ' - PERIOD_TYPE_UNSPECIFIED: Не указан.\n - PERIOD_TYPE_QUARTER: Квартальный.\n - PERIOD_TYPE_SEMIANNUAL: Полугодовой.\n - PERIOD_TYPE_ANNUAL: Годовой.',
    });

/**
 * Отчет
 */
export const zGetAssetReportsResponseGetAssetReportsEvent = z.object({
    instrumentId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента.',
        }),
    ),
    reportDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата публикации отчета.',
        }),
    ),
    periodYear: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Год периода отчета.',
        }),
    ),
    periodNum: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Номер периода.',
        }),
    ),
    periodType: z.optional(zGetAssetReportsResponseAssetReportPeriodType),
    createdAt: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата создания записи.',
        }),
    ),
});

/**
 *  - EVENT_TYPE_UNSPECIFIED: Неопределенное значение.
 * - EVENT_TYPE_CPN: Купон.
 * - EVENT_TYPE_CALL: Опцион (оферта).
 * - EVENT_TYPE_MTY: Погашение.
 * - EVENT_TYPE_CONV: Конвертация.
 */
export const zGetBondEventsRequestEventType = z
    .enum([
        'EVENT_TYPE_UNSPECIFIED',
        'EVENT_TYPE_CPN',
        'EVENT_TYPE_CALL',
        'EVENT_TYPE_MTY',
        'EVENT_TYPE_CONV',
    ])
    .register(z.globalRegistry, {
        description:
            ' - EVENT_TYPE_UNSPECIFIED: Неопределенное значение.\n - EVENT_TYPE_CPN: Купон.\n - EVENT_TYPE_CALL: Опцион (оферта).\n - EVENT_TYPE_MTY: Погашение.\n - EVENT_TYPE_CONV: Конвертация.',
    });

/**
 * Избранная группа
 */
export const zGetFavoriteGroupsResponseFavoriteGroup = z.object({
    groupId: z.string().register(z.globalRegistry, {
        description: 'Уникальный идентификатор группы.',
    }),
    groupName: z.string().register(z.globalRegistry, {
        description: 'Название группы.',
    }),
    color: z.string().register(z.globalRegistry, {
        description: 'Цвет группы в HEX-формате.',
    }),
    size: z.int().register(z.globalRegistry, {
        description: 'Количество инструментов в группе.',
    }),
    containsInstrument: z.optional(
        z.boolean().register(z.globalRegistry, {
            description: 'Признак наличия в группе хотя бы одного инструмента из запроса.',
        }),
    ),
});

export const zGetMaxLotsResponseSellLimitsView = z.object({
    sellMaxLots: z.optional(z.string()),
});

/**
 * Интервал свечи.
 *
 * - INDICATOR_INTERVAL_UNSPECIFIED: Интервал не определен.
 * - INDICATOR_INTERVAL_ONE_MINUTE: 1 минута.
 * - INDICATOR_INTERVAL_FIVE_MINUTES: 5 минут.
 * - INDICATOR_INTERVAL_FIFTEEN_MINUTES: 15 минут.
 * - INDICATOR_INTERVAL_ONE_HOUR: 1 час.
 * - INDICATOR_INTERVAL_ONE_DAY: 1 день.
 * - INDICATOR_INTERVAL_2_MIN: 2 минуты.
 * - INDICATOR_INTERVAL_3_MIN: 3 минуты.
 * - INDICATOR_INTERVAL_10_MIN: 10 минут.
 * - INDICATOR_INTERVAL_30_MIN: 30 минут.
 * - INDICATOR_INTERVAL_2_HOUR: 2 часа.
 * - INDICATOR_INTERVAL_4_HOUR: 4 часа.
 * - INDICATOR_INTERVAL_WEEK: Неделя.
 * - INDICATOR_INTERVAL_MONTH: Месяц.
 */
export const zGetTechAnalysisRequestIndicatorInterval = z
    .enum([
        'INDICATOR_INTERVAL_UNSPECIFIED',
        'INDICATOR_INTERVAL_ONE_MINUTE',
        'INDICATOR_INTERVAL_FIVE_MINUTES',
        'INDICATOR_INTERVAL_FIFTEEN_MINUTES',
        'INDICATOR_INTERVAL_ONE_HOUR',
        'INDICATOR_INTERVAL_ONE_DAY',
        'INDICATOR_INTERVAL_2_MIN',
        'INDICATOR_INTERVAL_3_MIN',
        'INDICATOR_INTERVAL_10_MIN',
        'INDICATOR_INTERVAL_30_MIN',
        'INDICATOR_INTERVAL_2_HOUR',
        'INDICATOR_INTERVAL_4_HOUR',
        'INDICATOR_INTERVAL_WEEK',
        'INDICATOR_INTERVAL_MONTH',
    ])
    .register(z.globalRegistry, {
        description:
            'Интервал свечи.\n\n - INDICATOR_INTERVAL_UNSPECIFIED: Интервал не определен.\n - INDICATOR_INTERVAL_ONE_MINUTE: 1 минута.\n - INDICATOR_INTERVAL_FIVE_MINUTES: 5 минут.\n - INDICATOR_INTERVAL_FIFTEEN_MINUTES: 15 минут.\n - INDICATOR_INTERVAL_ONE_HOUR: 1 час.\n - INDICATOR_INTERVAL_ONE_DAY: 1 день.\n - INDICATOR_INTERVAL_2_MIN: 2 минуты.\n - INDICATOR_INTERVAL_3_MIN: 3 минуты.\n - INDICATOR_INTERVAL_10_MIN: 10 минут.\n - INDICATOR_INTERVAL_30_MIN: 30 минут.\n - INDICATOR_INTERVAL_2_HOUR: 2 часа.\n - INDICATOR_INTERVAL_4_HOUR: 4 часа.\n - INDICATOR_INTERVAL_WEEK: Неделя.\n - INDICATOR_INTERVAL_MONTH: Месяц.',
    });

/**
 *  - INDICATOR_TYPE_UNSPECIFIED: Не определен.
 * - INDICATOR_TYPE_BB: Bollinger Bands — линия Боллинжера.
 * - INDICATOR_TYPE_EMA: Exponential Moving Average — EMA, экспоненциальная скользящая средняя.
 * - INDICATOR_TYPE_RSI: Relative Strength Index — индекс относительной силы.
 * - INDICATOR_TYPE_MACD: Moving Average Convergence/Divergence — схождение/расхождение скользящих средних.
 * - INDICATOR_TYPE_SMA: Simple Moving Average — простое скользящее среднее.
 */
export const zGetTechAnalysisRequestIndicatorType = z
    .enum([
        'INDICATOR_TYPE_UNSPECIFIED',
        'INDICATOR_TYPE_BB',
        'INDICATOR_TYPE_EMA',
        'INDICATOR_TYPE_RSI',
        'INDICATOR_TYPE_MACD',
        'INDICATOR_TYPE_SMA',
    ])
    .register(z.globalRegistry, {
        description:
            ' - INDICATOR_TYPE_UNSPECIFIED: Не определен.\n - INDICATOR_TYPE_BB: Bollinger Bands — линия Боллинжера.\n - INDICATOR_TYPE_EMA: Exponential Moving Average — EMA, экспоненциальная скользящая средняя.\n - INDICATOR_TYPE_RSI: Relative Strength Index — индекс относительной силы.\n - INDICATOR_TYPE_MACD: Moving Average Convergence/Divergence — схождение/расхождение скользящих средних.\n - INDICATOR_TYPE_SMA: Simple Moving Average — простое скользящее среднее.',
    });

export const zGetTechAnalysisRequestSmoothing = z.object({
    fastLength: z.optional(
        z.int().register(z.globalRegistry, {
            description:
                'Короткий период сглаживания для первой экспоненциальной скользящей средней (EMA).',
        }),
    ),
    slowLength: z.optional(
        z.int().register(z.globalRegistry, {
            description:
                'Длинный период сглаживания для второй экспоненциальной скользящей средней (EMA).',
        }),
    ),
    signalSmoothing: z.optional(z.int()),
});

/**
 *  - TYPE_OF_PRICE_UNSPECIFIED: Не указано.
 * - TYPE_OF_PRICE_CLOSE: Цена закрытия.
 * - TYPE_OF_PRICE_OPEN: Цена открытия.
 * - TYPE_OF_PRICE_HIGH: Максимальное значение за выбранный интервал.
 * - TYPE_OF_PRICE_LOW: Минимальное значение за выбранный интервал.
 * - TYPE_OF_PRICE_AVG: Среднее значение по показателям [ (close + open + high + low) / 4 ].
 */
export const zGetTechAnalysisRequestTypeOfPrice = z
    .enum([
        'TYPE_OF_PRICE_UNSPECIFIED',
        'TYPE_OF_PRICE_CLOSE',
        'TYPE_OF_PRICE_OPEN',
        'TYPE_OF_PRICE_HIGH',
        'TYPE_OF_PRICE_LOW',
        'TYPE_OF_PRICE_AVG',
    ])
    .register(z.globalRegistry, {
        description:
            ' - TYPE_OF_PRICE_UNSPECIFIED: Не указано.\n - TYPE_OF_PRICE_CLOSE: Цена закрытия.\n - TYPE_OF_PRICE_OPEN: Цена открытия.\n - TYPE_OF_PRICE_HIGH: Максимальное значение за выбранный интервал.\n - TYPE_OF_PRICE_LOW: Минимальное значение за выбранный интервал.\n - TYPE_OF_PRICE_AVG: Среднее значение по показателям [ (close + open + high + low) / 4 ].',
    });

/**
 * Маркер
 *
 * - MARKER_UNKNOWN: не определено
 * - MARKER_BROKER: сделки брокера
 * - MARKER_CHAT: исполнение поручение, полученного от клиента через каналы связи
 * - MARKER_PAPER: исполнение поручение, полученного от клиента в бумажной форме
 * - MARKER_MARGIN: принудительное закрытие позиций
 * - MARKER_TKBNM: сделки по управлению ликвидностью
 * - MARKER_SHORT: сделки РЕПО по привлечению у клиентов бумаг
 * - MARKER_SPECMM: перенос временно непокрытых позиций
 */
export const zOrderStateStreamResponseMarkerType = z
    .enum([
        'MARKER_UNKNOWN',
        'MARKER_BROKER',
        'MARKER_CHAT',
        'MARKER_PAPER',
        'MARKER_MARGIN',
        'MARKER_TKBNM',
        'MARKER_SHORT',
        'MARKER_SPECMM',
        'MARKER_PO',
    ])
    .register(z.globalRegistry, {
        description:
            '- MARKER_UNKNOWN: не определено\n - MARKER_BROKER: сделки брокера\n - MARKER_CHAT: исполнение поручение, полученного от клиента через каналы связи\n - MARKER_PAPER: исполнение поручение, полученного от клиента в бумажной форме\n - MARKER_MARGIN: принудительное закрытие позиций\n - MARKER_TKBNM: сделки по управлению ликвидностью\n - MARKER_SHORT: сделки РЕПО по привлечению у клиентов бумаг\n - MARKER_SPECMM: перенос временно непокрытых позиций',
    });

/**
 * Дополнительная информация по статусу заявки
 *
 * - CAUSE_UNSPECIFIED: Не определено
 * - CAUSE_CANCELLED_BY_CLIENT: Отменено клиентом
 * - CAUSE_CANCELLED_BY_EXCHANGE: Отменено биржей
 * - CAUSE_CANCELLED_NOT_ENOUGH_POSITION: Заявка не выставлена из-за нехватки средств
 * - CAUSE_CANCELLED_BY_CLIENT_BLOCK: Отменено из-за блокировки клиента
 * - CAUSE_REJECTED_BY_BROKER: Отклонено брокером
 * - CAUSE_REJECTED_BY_EXCHANGE: Отклонено биржей
 * - CAUSE_CANCELLED_BY_BROKER: Отменено брокером
 */
export const zOrderStateStreamResponseStatusCauseInfo = z
    .enum([
        'CAUSE_UNSPECIFIED',
        'CAUSE_CANCELLED_BY_CLIENT',
        'CAUSE_CANCELLED_BY_EXCHANGE',
        'CAUSE_CANCELLED_NOT_ENOUGH_POSITION',
        'CAUSE_CANCELLED_BY_CLIENT_BLOCK',
        'CAUSE_REJECTED_BY_BROKER',
        'CAUSE_REJECTED_BY_EXCHANGE',
        'CAUSE_CANCELLED_BY_BROKER',
    ])
    .register(z.globalRegistry, {
        description:
            '- CAUSE_UNSPECIFIED: Не определено\n - CAUSE_CANCELLED_BY_CLIENT: Отменено клиентом\n - CAUSE_CANCELLED_BY_EXCHANGE: Отменено биржей\n - CAUSE_CANCELLED_NOT_ENOUGH_POSITION: Заявка не выставлена из-за нехватки средств\n - CAUSE_CANCELLED_BY_CLIENT_BLOCK: Отменено из-за блокировки клиента\n - CAUSE_REJECTED_BY_BROKER: Отклонено брокером\n - CAUSE_REJECTED_BY_EXCHANGE: Отклонено биржей\n - CAUSE_CANCELLED_BY_BROKER: Отменено брокером',
    });

/**
 * - RUB: Рубли
 * - USD: Доллары
 * - EUR: Евро
 */
export const zPortfolioRequestCurrencyRequest = z.enum(['RUB', 'USD', 'EUR']);

/**
 * Стратегия портфеля.
 *
 * - LOGIC_PORTFOLIO_UNSPECIFIED: Стратегия портфеля не определена.
 * - LOGIC_PORTFOLIO_VOLATILITY: Волатильность.
 * - LOGIC_PORTFOLIO_CORRELATION: Корреляция.
 */
export const zStructuredNoteLogicPortfolio = z
    .enum([
        'LOGIC_PORTFOLIO_UNSPECIFIED',
        'LOGIC_PORTFOLIO_VOLATILITY',
        'LOGIC_PORTFOLIO_CORRELATION',
    ])
    .register(z.globalRegistry, {
        description:
            'Стратегия портфеля.\n\n - LOGIC_PORTFOLIO_UNSPECIFIED: Стратегия портфеля не определена.\n - LOGIC_PORTFOLIO_VOLATILITY: Волатильность.\n - LOGIC_PORTFOLIO_CORRELATION: Корреляция.',
    });

/**
 * Принцип наблюдений.
 *
 * - OBSERVATION_PRINCIPLE_UNSPECIFIED: Принцип наблюдений не определен.
 * - OBSERVATION_PRINCIPLE_WORST_BASIC_ASSET: По худшему базовому активу.
 * - OBSERVATION_PRINCIPLE_BEST_BASIC_ASSET: По лучшему базовому активу.
 * - OBSERVATION_PRINCIPLE_AVERAGE_OF_BASIC_ASSETS: Среднее значение по базовым активам.
 * - OBSERVATION_PRINCIPLE_SINGLE_BASIC_ASSET_PERFORMANCE: Динамика актива (только если у ноты один базовый актив).
 */
export const zStructuredNoteObservationPrinciple = z
    .enum([
        'OBSERVATION_PRINCIPLE_UNSPECIFIED',
        'OBSERVATION_PRINCIPLE_WORST_BASIC_ASSET',
        'OBSERVATION_PRINCIPLE_BEST_BASIC_ASSET',
        'OBSERVATION_PRINCIPLE_AVERAGE_OF_BASIC_ASSETS',
        'OBSERVATION_PRINCIPLE_SINGLE_BASIC_ASSET_PERFORMANCE',
    ])
    .register(z.globalRegistry, {
        description:
            'Принцип наблюдений.\n\n - OBSERVATION_PRINCIPLE_UNSPECIFIED: Принцип наблюдений не определен.\n - OBSERVATION_PRINCIPLE_WORST_BASIC_ASSET: По худшему базовому активу.\n - OBSERVATION_PRINCIPLE_BEST_BASIC_ASSET: По лучшему базовому активу.\n - OBSERVATION_PRINCIPLE_AVERAGE_OF_BASIC_ASSETS: Среднее значение по базовым активам.\n - OBSERVATION_PRINCIPLE_SINGLE_BASIC_ASSET_PERFORMANCE: Динамика актива (только если у ноты один базовый актив).',
    });

/**
 * Тип доходности.
 *
 * - YIELD_TYPE_UNSPECIFIED: Тип доходности не определен.
 * - YIELD_TYPE_GUARANTED_COUPON: Гарантированный купон.
 * - YIELD_TYPE_CONDITIONAL_COUPON: Условный купон.
 * - YIELD_TYPE_PARTICIPATION: Участие в росте.
 */
export const zStructuredNoteYieldType = z
    .enum([
        'YIELD_TYPE_UNSPECIFIED',
        'YIELD_TYPE_GUARANTED_COUPON',
        'YIELD_TYPE_CONDITIONAL_COUPON',
        'YIELD_TYPE_PARTICIPATION',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип доходности.\n\n - YIELD_TYPE_UNSPECIFIED: Тип доходности не определен.\n - YIELD_TYPE_GUARANTED_COUPON: Гарантированный купон.\n - YIELD_TYPE_CONDITIONAL_COUPON: Условный купон.\n - YIELD_TYPE_PARTICIPATION: Участие в росте.',
    });

export const zTradingIntervalTimeInterval = z.object({
    startTs: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Время начала интервала.',
        }),
    ),
    endTs: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Время окончания интервала.',
        }),
    ),
});

/**
 *  - CANDLE_SOURCE_UNSPECIFIED: Источник свечей не определен.
 * - CANDLE_SOURCE_EXCHANGE: Биржевые свечи.
 * - CANDLE_SOURCE_DEALER_WEEKEND: Свечи  дилера в результате торговли по выходным.
 */
export const zContractv1CandleSource = z
    .enum(['CANDLE_SOURCE_UNSPECIFIED', 'CANDLE_SOURCE_EXCHANGE', 'CANDLE_SOURCE_DEALER_WEEKEND'])
    .register(z.globalRegistry, {
        description:
            ' - CANDLE_SOURCE_UNSPECIFIED: Источник свечей не определен.\n - CANDLE_SOURCE_EXCHANGE: Биржевые свечи.\n - CANDLE_SOURCE_DEALER_WEEKEND: Свечи  дилера в результате торговли по выходным.',
    });

/**
 * Направление сделки.
 *
 * - TRADE_DIRECTION_UNSPECIFIED: Направление сделки не определено.
 * - TRADE_DIRECTION_BUY: Покупка.
 * - TRADE_DIRECTION_SELL: Продажа.
 */
export const zContractv1TradeDirection = z
    .enum(['TRADE_DIRECTION_UNSPECIFIED', 'TRADE_DIRECTION_BUY', 'TRADE_DIRECTION_SELL'])
    .register(z.globalRegistry, {
        description:
            'Направление сделки.\n\n - TRADE_DIRECTION_UNSPECIFIED: Направление сделки не определено.\n - TRADE_DIRECTION_BUY: Покупка.\n - TRADE_DIRECTION_SELL: Продажа.',
    });

export const zProtobufAny = z.object({
    '@type': z.optional(z.string()),
});

export const zRpcStatus = z.object({
    code: z.optional(z.int()),
    message: z.optional(z.string()),
    details: z.optional(z.array(zProtobufAny)),
});

/**
 * Уровень доступа к счeту.
 *
 * - ACCOUNT_ACCESS_LEVEL_UNSPECIFIED: Уровень доступа не определeн.
 * - ACCOUNT_ACCESS_LEVEL_FULL_ACCESS: Полный доступ к счeту.
 * - ACCOUNT_ACCESS_LEVEL_READ_ONLY: Доступ с уровнем прав «только чтение».
 * - ACCOUNT_ACCESS_LEVEL_NO_ACCESS: Доступа нет.
 */
export const zV1AccessLevel = z
    .enum([
        'ACCOUNT_ACCESS_LEVEL_UNSPECIFIED',
        'ACCOUNT_ACCESS_LEVEL_FULL_ACCESS',
        'ACCOUNT_ACCESS_LEVEL_READ_ONLY',
        'ACCOUNT_ACCESS_LEVEL_NO_ACCESS',
    ])
    .register(z.globalRegistry, {
        description:
            'Уровень доступа к счeту.\n\n - ACCOUNT_ACCESS_LEVEL_UNSPECIFIED: Уровень доступа не определeн.\n - ACCOUNT_ACCESS_LEVEL_FULL_ACCESS: Полный доступ к счeту.\n - ACCOUNT_ACCESS_LEVEL_READ_ONLY: Доступ с уровнем прав «только чтение».\n - ACCOUNT_ACCESS_LEVEL_NO_ACCESS: Доступа нет.',
    });

/**
 * Статус счeта.
 *
 * - ACCOUNT_STATUS_UNSPECIFIED: Статус счeта не определeн.
 * - ACCOUNT_STATUS_NEW: Новый, в процессе открытия.
 * - ACCOUNT_STATUS_OPEN: Открытый и активный счeт.
 * - ACCOUNT_STATUS_CLOSED: Закрытый счeт.
 * - ACCOUNT_STATUS_ALL: Все счета.
 */
export const zV1AccountStatus = z
    .enum([
        'ACCOUNT_STATUS_UNSPECIFIED',
        'ACCOUNT_STATUS_NEW',
        'ACCOUNT_STATUS_OPEN',
        'ACCOUNT_STATUS_CLOSED',
        'ACCOUNT_STATUS_ALL',
    ])
    .register(z.globalRegistry, {
        description:
            'Статус счeта.\n\n - ACCOUNT_STATUS_UNSPECIFIED: Статус счeта не определeн.\n - ACCOUNT_STATUS_NEW: Новый, в процессе открытия.\n - ACCOUNT_STATUS_OPEN: Открытый и активный счeт.\n - ACCOUNT_STATUS_CLOSED: Закрытый счeт.\n - ACCOUNT_STATUS_ALL: Все счета.',
    });

/**
 * Тип счeта.
 *
 * - ACCOUNT_TYPE_UNSPECIFIED: Тип аккаунта не определeн.
 * - ACCOUNT_TYPE_TINKOFF: Брокерский счeт Т-Инвестиций.
 * - ACCOUNT_TYPE_TINKOFF_IIS: ИИС.
 * - ACCOUNT_TYPE_INVEST_BOX: Инвесткопилка.
 * - ACCOUNT_TYPE_INVEST_FUND: Фонд денежного рынка.
 * - ACCOUNT_TYPE_DEBIT: Дебетовый карточный счeт.
 * - ACCOUNT_TYPE_SAVING: Накопительный счeт.
 */
export const zV1AccountType = z
    .enum([
        'ACCOUNT_TYPE_UNSPECIFIED',
        'ACCOUNT_TYPE_TINKOFF',
        'ACCOUNT_TYPE_TINKOFF_IIS',
        'ACCOUNT_TYPE_INVEST_BOX',
        'ACCOUNT_TYPE_INVEST_FUND',
        'ACCOUNT_TYPE_DEBIT',
        'ACCOUNT_TYPE_SAVING',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип счeта.\n\n - ACCOUNT_TYPE_UNSPECIFIED: Тип аккаунта не определeн.\n - ACCOUNT_TYPE_TINKOFF: Брокерский счeт Т-Инвестиций.\n - ACCOUNT_TYPE_TINKOFF_IIS: ИИС.\n - ACCOUNT_TYPE_INVEST_BOX: Инвесткопилка.\n - ACCOUNT_TYPE_INVEST_FUND: Фонд денежного рынка.\n - ACCOUNT_TYPE_DEBIT: Дебетовый карточный счeт.\n - ACCOUNT_TYPE_SAVING: Накопительный счeт.',
    });

/**
 * Информация о счeте.
 */
export const zV1Account = z
    .object({
        id: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счeта.',
            }),
        ),
        type: z.optional(zV1AccountType),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название счeта.',
            }),
        ),
        status: z.optional(zV1AccountStatus),
        openedDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата открытия счeта в часовом поясе UTC.',
            }),
        ),
        closedDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата закрытия счeта в часовом поясе UTC.',
            }),
        ),
        accessLevel: z.optional(zV1AccessLevel),
    })
    .register(z.globalRegistry, {
        description: 'Информация о счeте.',
    });

/**
 * Валюта.
 */
export const zV1AssetCurrency = z
    .object({
        baseCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISO-код валюты.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Валюта.',
    });

/**
 * Запрос актива по идентификатору.
 */
export const zV1AssetRequest = z
    .object({
        id: z.string().register(z.globalRegistry, {
            description: 'UID-идентификатор актива.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос актива по идентификатору.',
    });

/**
 * Тип актива.
 *
 * - ASSET_TYPE_UNSPECIFIED: Тип не определен.
 * - ASSET_TYPE_CURRENCY: Валюта.
 * - ASSET_TYPE_COMMODITY: Товар.
 * - ASSET_TYPE_INDEX: Индекс.
 * - ASSET_TYPE_SECURITY: Ценная бумага.
 */
export const zV1AssetType = z
    .enum([
        'ASSET_TYPE_UNSPECIFIED',
        'ASSET_TYPE_CURRENCY',
        'ASSET_TYPE_COMMODITY',
        'ASSET_TYPE_INDEX',
        'ASSET_TYPE_SECURITY',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип актива.\n\n - ASSET_TYPE_UNSPECIFIED: Тип не определен.\n - ASSET_TYPE_CURRENCY: Валюта.\n - ASSET_TYPE_COMMODITY: Товар.\n - ASSET_TYPE_INDEX: Индекс.\n - ASSET_TYPE_SECURITY: Ценная бумага.',
    });

/**
 *  - BOND_TYPE_UNSPECIFIED: Тип облигации не определен.
 * - BOND_TYPE_REPLACED: Замещающая облигация.
 */
export const zV1BondType = z
    .enum(['BOND_TYPE_UNSPECIFIED', 'BOND_TYPE_REPLACED'])
    .register(z.globalRegistry, {
        description:
            ' - BOND_TYPE_UNSPECIFIED: Тип облигации не определен.\n - BOND_TYPE_REPLACED: Замещающая облигация.',
    });

/**
 * Бренд.
 */
export const zV1Brand = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID-идентификатор бренда.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование бренда.',
            }),
        ),
        description: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Описание.',
            }),
        ),
        info: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Информация о бренде.',
            }),
        ),
        company: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Компания.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор.',
            }),
        ),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Код страны риска.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование страны риска.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Бренд.',
    });

export const zV1BrandData = z.object({
    logoName: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Логотип инструмента. Имя файла для получения логотипа.',
        }),
    ),
    logoBaseColor: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Цвет бренда.',
        }),
    ),
    textColor: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Цвет текста для цвета логотипа бренда.',
        }),
    ),
});

/**
 * Запрос отмены выставленной стоп-заявки.
 */
export const zV1CancelStopOrderRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета клиента.',
        }),
        stopOrderId: z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор стоп-заявки.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос отмены выставленной стоп-заявки.',
    });

/**
 * Результат отмены выставленной стоп-заявки.
 */
export const zV1CancelStopOrderResponse = z
    .object({
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время отмены заявки по UTC.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат отмены выставленной стоп-заявки.',
    });

/**
 * Интервал свечей. Максимальное значение интервала приведено ориентировочно, может отличаться в большую сторону в зависимости от параметров запроса.
 *
 * - CANDLE_INTERVAL_UNSPECIFIED: Интервал не определен.
 * - CANDLE_INTERVAL_1_MIN: От 1 минуты до 1 дня. Максимальное значение `limit` — 2400.
 * - CANDLE_INTERVAL_5_MIN: От 5 минут до недели. Максимальное значение `limit` — 2400.
 * - CANDLE_INTERVAL_15_MIN: От 15 минут до 3 недель. Максимальное значение `limit` — 2400.
 * - CANDLE_INTERVAL_HOUR: От 1 часа до 3 месяцев. Максимальное значение `limit` — 2400.
 * - CANDLE_INTERVAL_DAY: От 1 дня до 6 лет. Максимальное значение `limit` — 2400.
 * - CANDLE_INTERVAL_2_MIN: От 2 минут до 1 дня. Максимальное значение `limit` — 1200.
 * - CANDLE_INTERVAL_3_MIN: От 3 минут до 1 дня. Максимальное значение `limit` — 750.
 * - CANDLE_INTERVAL_10_MIN: От 10 минут до недели. Максимальное значение `limit` — 1200.
 * - CANDLE_INTERVAL_30_MIN: От 30 минут до 3 недель. Максимальное значение `limit` — 1200.
 * - CANDLE_INTERVAL_2_HOUR: От 2 часов до 3 месяцев. Максимальное значение `limit` — 2400.
 * - CANDLE_INTERVAL_4_HOUR: От 4 часов до 3 месяцев. Максимальное значение `limit` — 700.
 * - CANDLE_INTERVAL_WEEK: От 1 недели до 5 лет. Максимальное значение `limit` — 300.
 * - CANDLE_INTERVAL_MONTH: От 1 месяца до 10 лет. Максимальное значение `limit` — 120.
 * - CANDLE_INTERVAL_5_SEC: От 5 секунд до 200 минут. Максимальное значение `limit` — 2500.
 * - CANDLE_INTERVAL_10_SEC: От 10 секунд до 200 минут. Максимальное значение `limit` — 1250.
 * - CANDLE_INTERVAL_30_SEC: От 30 секунд до 20 часов. Максимальное значение `limit` — 2500.
 */
export const zV1CandleInterval = z
    .enum([
        'CANDLE_INTERVAL_UNSPECIFIED',
        'CANDLE_INTERVAL_1_MIN',
        'CANDLE_INTERVAL_5_MIN',
        'CANDLE_INTERVAL_15_MIN',
        'CANDLE_INTERVAL_HOUR',
        'CANDLE_INTERVAL_DAY',
        'CANDLE_INTERVAL_2_MIN',
        'CANDLE_INTERVAL_3_MIN',
        'CANDLE_INTERVAL_10_MIN',
        'CANDLE_INTERVAL_30_MIN',
        'CANDLE_INTERVAL_2_HOUR',
        'CANDLE_INTERVAL_4_HOUR',
        'CANDLE_INTERVAL_WEEK',
        'CANDLE_INTERVAL_MONTH',
        'CANDLE_INTERVAL_5_SEC',
        'CANDLE_INTERVAL_10_SEC',
        'CANDLE_INTERVAL_30_SEC',
    ])
    .register(z.globalRegistry, {
        description:
            'Интервал свечей. Максимальное значение интервала приведено ориентировочно, может отличаться в большую сторону в зависимости от параметров запроса.\n\n - CANDLE_INTERVAL_UNSPECIFIED: Интервал не определен.\n - CANDLE_INTERVAL_1_MIN: От 1 минуты до 1 дня. Максимальное значение `limit` — 2400.\n - CANDLE_INTERVAL_5_MIN: От 5 минут до недели. Максимальное значение `limit` — 2400.\n - CANDLE_INTERVAL_15_MIN: От 15 минут до 3 недель. Максимальное значение `limit` — 2400.\n - CANDLE_INTERVAL_HOUR: От 1 часа до 3 месяцев. Максимальное значение `limit` — 2400.\n - CANDLE_INTERVAL_DAY: От 1 дня до 6 лет. Максимальное значение `limit` — 2400.\n - CANDLE_INTERVAL_2_MIN: От 2 минут до 1 дня. Максимальное значение `limit` — 1200.\n - CANDLE_INTERVAL_3_MIN: От 3 минут до 1 дня. Максимальное значение `limit` — 750.\n - CANDLE_INTERVAL_10_MIN: От 10 минут до недели. Максимальное значение `limit` — 1200.\n - CANDLE_INTERVAL_30_MIN: От 30 минут до 3 недель. Максимальное значение `limit` — 1200.\n - CANDLE_INTERVAL_2_HOUR: От 2 часов до 3 месяцев. Максимальное значение `limit` — 2400.\n - CANDLE_INTERVAL_4_HOUR: От 4 часов до 3 месяцев. Максимальное значение `limit` — 700.\n - CANDLE_INTERVAL_WEEK: От 1 недели до 5 лет. Максимальное значение `limit` — 300.\n - CANDLE_INTERVAL_MONTH: От 1 месяца до 10 лет. Максимальное значение `limit` — 120.\n - CANDLE_INTERVAL_5_SEC: От 5 секунд до 200 минут. Максимальное значение `limit` — 2500.\n - CANDLE_INTERVAL_10_SEC: От 10 секунд до 200 минут. Максимальное значение `limit` — 1250.\n - CANDLE_INTERVAL_30_SEC: От 30 секунд до 20 часов. Максимальное значение `limit` — 2500.',
    });

/**
 * Запрос закрытия счета в песочнице.
 */
export const zV1CloseSandboxAccountRequest = z
    .object({
        accountId: z.string(),
    })
    .register(z.globalRegistry, {
        description: 'Запрос закрытия счета в песочнице.',
    });

/**
 * Результат закрытия счета в песочнице.
 *
 * пустой ответ
 */
export const zV1CloseSandboxAccountResponse = z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
        description: 'Результат закрытия счета в песочнице.\n\nпустой ответ',
    });

/**
 * Данные о стране.
 */
export const zV1CountryResponse = z
    .object({
        alfaTwo: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Двухбуквенный код страны.',
            }),
        ),
        alfaThree: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Трехбуквенный код страны.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование страны.',
            }),
        ),
        nameBrief: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Краткое наименование страны.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные о стране.',
    });

/**
 * Тип купонов.
 *
 * - COUPON_TYPE_UNSPECIFIED: Неопределенное значение.
 * - COUPON_TYPE_CONSTANT: Постоянный.
 * - COUPON_TYPE_FLOATING: Плавающий.
 * - COUPON_TYPE_DISCOUNT: Дисконт.
 * - COUPON_TYPE_MORTGAGE: Ипотечный.
 * - COUPON_TYPE_FIX: Фиксированный.
 * - COUPON_TYPE_VARIABLE: Переменный.
 * - COUPON_TYPE_OTHER: Прочее.
 */
export const zV1CouponType = z
    .enum([
        'COUPON_TYPE_UNSPECIFIED',
        'COUPON_TYPE_CONSTANT',
        'COUPON_TYPE_FLOATING',
        'COUPON_TYPE_DISCOUNT',
        'COUPON_TYPE_MORTGAGE',
        'COUPON_TYPE_FIX',
        'COUPON_TYPE_VARIABLE',
        'COUPON_TYPE_OTHER',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип купонов.\n\n - COUPON_TYPE_UNSPECIFIED: Неопределенное значение.\n - COUPON_TYPE_CONSTANT: Постоянный.\n - COUPON_TYPE_FLOATING: Плавающий.\n - COUPON_TYPE_DISCOUNT: Дисконт.\n - COUPON_TYPE_MORTGAGE: Ипотечный.\n - COUPON_TYPE_FIX: Фиксированный.\n - COUPON_TYPE_VARIABLE: Переменный.\n - COUPON_TYPE_OTHER: Прочее.',
    });

/**
 * Запрос создания новой группы избранных инструментов.
 */
export const zV1CreateFavoriteGroupRequest = z
    .object({
        groupName: z.string().register(z.globalRegistry, {
            description: 'Название группы, не более 255 символов.',
        }),
        groupColor: z.string(),
        note: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Запрос создания новой группы избранных инструментов.',
    });

export const zV1CreateFavoriteGroupResponse = z.object({
    groupId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор группы.',
        }),
    ),
    groupName: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Название группы.',
        }),
    ),
});

export const zV1CurrencyTransferResponse = z.record(z.string(), z.unknown());

/**
 * Запрос удаления избранной группы
 */
export const zV1DeleteFavoriteGroupRequest = z.object({
    groupId: z.string().register(z.globalRegistry, {
        description: 'Уникальный идентификатор группы.',
    }),
});

export const zV1DeleteFavoriteGroupResponse = z.record(z.string(), z.unknown());

/**
 * Тип действия со списком избранных инструментов.
 *
 * - EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED: Тип не определен.
 * - EDIT_FAVORITES_ACTION_TYPE_ADD: Добавить в список.
 * - EDIT_FAVORITES_ACTION_TYPE_DEL: Удалить из списка.
 */
export const zV1EditFavoritesActionType = z
    .enum([
        'EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED',
        'EDIT_FAVORITES_ACTION_TYPE_ADD',
        'EDIT_FAVORITES_ACTION_TYPE_DEL',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип действия со списком избранных инструментов.\n\n - EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED: Тип не определен.\n - EDIT_FAVORITES_ACTION_TYPE_ADD: Добавить в список.\n - EDIT_FAVORITES_ACTION_TYPE_DEL: Удалить из списка.',
    });

/**
 * Массив инструментов для редактирования списка избранных инструментов.
 */
export const zV1EditFavoritesRequestInstrument = z
    .object({
        instrumentId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента — `figi` или `instrument_uid`.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Массив инструментов для редактирования списка избранных инструментов.',
    });

/**
 * Запрос редактирования списка избранных инструментов.
 */
export const zV1EditFavoritesRequest = z
    .object({
        instruments: z.array(zV1EditFavoritesRequestInstrument).register(z.globalRegistry, {
            description: 'Массив инструментов.',
        }),
        actionType: zV1EditFavoritesActionType,
        groupId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор группы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос редактирования списка избранных инструментов.',
    });

export const zV1ErrorDetail = z.object({
    code: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код ошибки.',
        }),
    ),
    message: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Описание ошибки.',
        }),
    ),
});

/**
 * Тип выставляемой заявки.
 *
 * - EXCHANGE_ORDER_TYPE_UNSPECIFIED: Значение не указано.
 * - EXCHANGE_ORDER_TYPE_MARKET: Заявка по рыночной цене.
 * - EXCHANGE_ORDER_TYPE_LIMIT: Лимитная заявка.
 */
export const zV1ExchangeOrderType = z
    .enum([
        'EXCHANGE_ORDER_TYPE_UNSPECIFIED',
        'EXCHANGE_ORDER_TYPE_MARKET',
        'EXCHANGE_ORDER_TYPE_LIMIT',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип выставляемой заявки.\n\n - EXCHANGE_ORDER_TYPE_UNSPECIFIED: Значение не указано.\n - EXCHANGE_ORDER_TYPE_MARKET: Заявка по рыночной цене.\n - EXCHANGE_ORDER_TYPE_LIMIT: Лимитная заявка.',
    });

/**
 * Параметры фильтрации опционов.
 */
export const zV1FilterOptionsRequest = z
    .object({
        basicAssetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор базового актива опциона.  Обязательный параметр.',
            }),
        ),
        basicAssetPositionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор позиции базового актива опциона.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Параметры фильтрации опционов.',
    });

export const zV1GenerateBrokerReportRequest = z.object({
    accountId: z.string().register(z.globalRegistry, {
        description: 'Идентификатор счета клиента.',
    }),
    from: z.iso.datetime().register(z.globalRegistry, {
        description: 'Начало периода по UTC.',
    }),
    to: z.iso.datetime().register(z.globalRegistry, {
        description: 'Окончание периода по UTC.',
    }),
});

export const zV1GenerateBrokerReportResponse = z.object({
    taskId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Идентификатор задачи формирования брокерского отчета.',
        }),
    ),
});

/**
 * Объект запроса формирования отчета «Справка о доходах за пределами РФ».
 */
export const zV1GenerateDividendsForeignIssuerReportRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета клиента.',
        }),
        from: z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало периода по UTC.',
        }),
        to: z.iso.datetime().register(z.globalRegistry, {
            description:
                'Окончание периода по UTC. Как правило, можно сформировать отчет по дату на несколько дней меньше текущей. Начало и окончание периода должны быть в рамках одного календарного года.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Объект запроса формирования отчета «Справка о доходах за пределами РФ».',
    });

/**
 * Объект результата задачи запуска формирования отчета «Справка о доходах за пределами РФ».
 */
export const zV1GenerateDividendsForeignIssuerReportResponse = z
    .object({
        taskId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор задачи формирования отчета.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description:
            'Объект результата задачи запуска формирования отчета «Справка о доходах за пределами РФ».',
    });

/**
 * Запрос получения счетов пользователя.
 */
export const zV1GetAccountsRequest = z
    .object({
        status: z.optional(zV1AccountStatus),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения счетов пользователя.',
    });

/**
 * Список счетов пользователя.
 */
export const zV1GetAccountsResponse = z
    .object({
        accounts: z.optional(
            z.array(zV1Account).register(z.globalRegistry, {
                description: 'Массив счетов клиента.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список счетов пользователя.',
    });

/**
 * Запрос НКД по облигации.
 */
export const zV1GetAccruedInterestsRequest = z
    .object({
        from: z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало запрашиваемого периода по UTC.',
        }),
        to: z.iso.datetime().register(z.globalRegistry, {
            description: 'Окончание запрашиваемого периода по UTC.',
        }),
        instrumentId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента — `figi` или `instrument_uid`.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос НКД по облигации.',
    });

/**
 * Запрос фундаментальных показателей
 */
export const zV1GetAssetFundamentalsRequest = z.object({
    assets: z.array(z.string()).register(z.globalRegistry, {
        description: 'Массив идентификаторов активов, не более 100 шт.',
    }),
});

/**
 * Фундаментальные показатели
 */
export const zV1GetAssetFundamentalsResponse = z.object({
    fundamentals: z.optional(z.array(zGetAssetFundamentalsResponseStatisticResponse)),
});

/**
 * Запрос отчетов эмитентов
 */
export const zV1GetAssetReportsRequest = z.object({
    instrumentId: z.string().register(z.globalRegistry, {
        description: 'Идентификатор инструмента в формате UID.',
    }),
    from: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало запрашиваемого периода по UTC.',
        }),
    ),
    to: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Окончание запрашиваемого периода по UTC.',
        }),
    ),
});

/**
 * Отчеты эмитентов
 */
export const zV1GetAssetReportsResponse = z.object({
    events: z.optional(
        z.array(zGetAssetReportsResponseGetAssetReportsEvent).register(z.globalRegistry, {
            description: 'Массив событий по облигации.',
        }),
    ),
});

/**
 * Запрос списка банковских счетов пользователя.
 */
export const zV1GetBankAccountsRequest = z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
        description: 'Запрос списка банковских счетов пользователя.',
    });

/**
 * Запрос купонов по облигации.
 */
export const zV1GetBondCouponsRequest = z
    .object({
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description:
                    'Начало запрашиваемого периода по UTC. Фильтрация по `coupon_date` — дата выплаты купона.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description:
                    'Окончание запрашиваемого периода по UTC. Фильтрация по `coupon_date` — дата выплаты купона.',
            }),
        ),
        instrumentId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента — `figi` или `instrument_uid`.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос купонов по облигации.',
    });

/**
 * События по облигации.
 */
export const zV1GetBondEventsRequest = z
    .object({
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Начало запрашиваемого периода по UTC.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Окончание запрашиваемого периода по UTC.',
            }),
        ),
        instrumentId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента — `figi` или `instrument_uid`.',
        }),
        type: z.optional(zGetBondEventsRequestEventType),
    })
    .register(z.globalRegistry, {
        description: 'События по облигации.',
    });

/**
 * Запрос бренда.
 */
export const zV1GetBrandRequest = z
    .object({
        id: z.string().register(z.globalRegistry, {
            description: 'UID-идентификатор бренда.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос бренда.',
    });

export const zV1GetBrokerReportRequest = z.object({
    taskId: z.string().register(z.globalRegistry, {
        description: 'Идентификатор задачи формирования брокерского отчета.',
    }),
    page: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Номер страницы отчета, начинается с 1. Значение по умолчанию — 0.',
        }),
    ),
});

export const zV1BrokerReportRequest = z.object({
    generateBrokerReportRequest: z.optional(zV1GenerateBrokerReportRequest),
    getBrokerReportRequest: z.optional(zV1GetBrokerReportRequest),
});

/**
 *  - CANDLE_SOURCE_UNSPECIFIED: Все свечи.
 * - CANDLE_SOURCE_EXCHANGE: Биржевые свечи.
 * - CANDLE_SOURCE_INCLUDE_WEEKEND: Все свечи с учетом торговли по выходным.
 */
export const zV1GetCandlesRequestCandleSource = z
    .enum(['CANDLE_SOURCE_UNSPECIFIED', 'CANDLE_SOURCE_EXCHANGE', 'CANDLE_SOURCE_INCLUDE_WEEKEND'])
    .register(z.globalRegistry, {
        description:
            ' - CANDLE_SOURCE_UNSPECIFIED: Все свечи.\n - CANDLE_SOURCE_EXCHANGE: Биржевые свечи.\n - CANDLE_SOURCE_INCLUDE_WEEKEND: Все свечи с учетом торговли по выходным.',
    });

/**
 * Запрос исторических свечей.
 */
export const zV1GetCandlesRequest = z
    .object({
        from: z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало запрашиваемого периода по UTC.',
        }),
        to: z.iso.datetime().register(z.globalRegistry, {
            description: 'Окончание запрашиваемого периода по UTC.',
        }),
        interval: zV1CandleInterval,
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
        candleSourceType: z.optional(zV1GetCandlesRequestCandleSource),
        limit: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Максимальное количество свечей в ответе.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос исторических свечей.',
    });

/**
 * Запрос справочника стран.
 */
export const zV1GetCountriesRequest = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Запрос справочника стран.',
});

/**
 * Справочник стран.
 */
export const zV1GetCountriesResponse = z
    .object({
        countries: z.optional(
            z.array(zV1CountryResponse).register(z.globalRegistry, {
                description: 'Массив стран.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Справочник стран.',
    });

/**
 * Объект запроса сформированного отчета «Справка о доходах за пределами РФ».
 */
export const zV1GetDividendsForeignIssuerReportRequest = z
    .object({
        taskId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор задачи формирования отчета.',
        }),
        page: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Номер страницы отчета (начинается с 0), значение по умолчанию: 0.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Объект запроса сформированного отчета «Справка о доходах за пределами РФ».',
    });

export const zV1GetDividendsForeignIssuerRequest = z.object({
    generateDivForeignIssuerReport: z.optional(zV1GenerateDividendsForeignIssuerReportRequest),
    getDivForeignIssuerReport: z.optional(zV1GetDividendsForeignIssuerReportRequest),
});

/**
 * Запрос дивидендов.
 */
export const zV1GetDividendsRequest = z
    .object({
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description:
                    'Начало запрашиваемого периода по UTC. Фильтрация происходит по параметру `record_date` — дата фиксации реестра.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description:
                    'Окончание запрашиваемого периода по UTC. Фильтрация происходит по параметру `record_date` — дата фиксации реестра.',
            }),
        ),
        instrumentId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента — `figi` или `instrument_uid`.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос дивидендов.',
    });

/**
 * Запрос получения списка избранных групп
 */
export const zV1GetFavoriteGroupsRequest = z.object({
    instrumentId: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description:
                'Массив идентификаторов инструментов. Принимает значение `figi` или `instrument_uid`. Если в группе будет хотя бы один из инструментов массива, то в ответе у группы вернется признак `containsInstrument = true`.',
        }),
    ),
    excludedGroupId: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description: 'Массив идентификаторов групп, которые необходимо исключить из ответа.',
        }),
    ),
});

/**
 * Избранные группы
 */
export const zV1GetFavoriteGroupsResponse = z.object({
    groups: z.optional(
        z.array(zGetFavoriteGroupsResponseFavoriteGroup).register(z.globalRegistry, {
            description: 'Массив групп избранных списков инструментов.',
        }),
    ),
});

/**
 * Запрос списка избранных инструментов, входные параметры не требуются.
 */
export const zV1GetFavoritesRequest = z
    .object({
        groupId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор группы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос списка избранных инструментов, входные параметры не требуются.',
    });

/**
 * Запрос прогнозов инвестдомов.
 */
export const zV1GetForecastRequest = z
    .object({
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор инструмента.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос прогнозов инвестдомов.',
    });

/**
 * Запрос информации о фьючерсе
 */
export const zV1GetFuturesMarginRequest = z.object({
    instrumentId: z.string().register(z.globalRegistry, {
        description: 'Идентификатор инструмента — `figi` или `instrument_uid`.',
    }),
});

/**
 * Запрос информации о пользователе.
 */
export const zV1GetInfoRequest = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Запрос информации о пользователе.',
});

/**
 * Информация о пользователе.
 */
export const zV1GetInfoResponse = z
    .object({
        premStatus: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак премиум клиента.',
            }),
        ),
        qualStatus: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак квалифицированного инвестора.',
            }),
        ),
        qualifiedForWorkWith: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Набор требующих тестирования инструментов и возможностей, с которыми может работать пользователь. [Подробнее](/invest/services/accounts/faq_users).',
            }),
        ),
        tariff: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование тарифа пользователя.',
            }),
        ),
        userId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор пользователя.',
            }),
        ),
        riskLevelCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Категория риска.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о пользователе.',
    });

/**
 * Запрос сделок по инсайдерам
 */
export const zV1GetInsiderDealsRequest = z.object({
    instrumentId: z.optional(z.string()),
    limit: z.optional(z.int()),
    nextCursor: z.optional(z.string()),
});

/**
 *  - TRADE_DIRECTION_UNSPECIFIED: Не определено.
 * - TRADE_DIRECTION_BUY: Покупка.
 * - TRADE_DIRECTION_SELL: Продажа.
 * - TRADE_DIRECTION_INCREASE: Увеличение доли.
 * - TRADE_DIRECTION_DECREASE: Уменьшение доли.
 */
export const zV1GetInsiderDealsResponseTradeDirection = z
    .enum([
        'TRADE_DIRECTION_UNSPECIFIED',
        'TRADE_DIRECTION_BUY',
        'TRADE_DIRECTION_SELL',
        'TRADE_DIRECTION_INCREASE',
        'TRADE_DIRECTION_DECREASE',
    ])
    .register(z.globalRegistry, {
        description:
            ' - TRADE_DIRECTION_UNSPECIFIED: Не определено.\n - TRADE_DIRECTION_BUY: Покупка.\n - TRADE_DIRECTION_SELL: Продажа.\n - TRADE_DIRECTION_INCREASE: Увеличение доли.\n - TRADE_DIRECTION_DECREASE: Уменьшение доли.',
    });

/**
 * Запрос маржинальных показателей по счeту.
 */
export const zV1GetMarginAttributesRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счeта пользователя.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос маржинальных показателей по счeту.',
    });

/**
 * Запрос активных подписок. Возвращает по одному сообщению на каждый тип активных подписок — `SubscribeLastPriceResponse`, `SubscribeInfoResponse`, `SubscribeTradesResponse`, `SubscribeOrderBookResponse`, `SubscribeCandlesResponse`.
 */
export const zV1GetMySubscriptions = z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description:
        'Запрос активных подписок. Возвращает по одному сообщению на каждый тип активных подписок — `SubscribeLastPriceResponse`, `SubscribeInfoResponse`, `SubscribeTradesResponse`, `SubscribeOrderBookResponse`, `SubscribeCandlesResponse`.',
});

/**
 * Запрос стакана.
 */
export const zV1GetOrderBookRequest = z
    .object({
        depth: z.int().register(z.globalRegistry, {
            description: 'Глубина стакана.',
        }),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос стакана.',
    });

/**
 * Запрос стратегий.
 */
export const zV1GetStrategiesRequest = z
    .object({
        strategyId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор стратегии.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос стратегий.',
    });

/**
 * Запрос получения торгового статуса.
 */
export const zV1GetTradingStatusRequest = z
    .object({
        instrumentId: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения торгового статуса.',
    });

/**
 * Запрос получения торгового статуса.
 */
export const zV1GetTradingStatusesRequest = z
    .object({
        instrumentId: z.optional(z.array(z.string())),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения торгового статуса.',
    });

/**
 * Запрос текущих лимитов пользователя.
 */
export const zV1GetUserTariffRequest = z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
        description: 'Запрос текущих лимитов пользователя.',
    });

/**
 * Запрос справочника индексов и товаров
 */
export const zV1IndicativesRequest = z.record(z.string(), z.unknown());

/**
 * Запрос подписки на торговый статус.
 */
export const zV1InfoInstrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.',
            }),
        ),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос подписки на торговый статус.',
    });

/**
 * Запрос цен закрытия торговой сессии по инструменту.
 */
export const zV1InstrumentClosePriceRequest = z
    .object({
        instrumentId: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Запрос цен закрытия торговой сессии по инструменту.',
    });

/**
 * Площадка торговли.
 *
 * - INSTRUMENT_EXCHANGE_UNSPECIFIED: Площадка торговли не определена.
 * - INSTRUMENT_EXCHANGE_DEALER: Бумага, торгуемая у дилера.
 */
export const zV1InstrumentExchangeType = z
    .enum(['INSTRUMENT_EXCHANGE_UNSPECIFIED', 'INSTRUMENT_EXCHANGE_DEALER'])
    .register(z.globalRegistry, {
        description:
            'Площадка торговли.\n\n - INSTRUMENT_EXCHANGE_UNSPECIFIED: Площадка торговли не определена.\n - INSTRUMENT_EXCHANGE_DEALER: Бумага, торгуемая у дилера.',
    });

/**
 * Тип идентификатора инструмента. [Подробнее об идентификации инструментов](./faq_identification/).
 *
 * - INSTRUMENT_ID_UNSPECIFIED: Значение не определено.
 * - INSTRUMENT_ID_TYPE_FIGI: FIGI.
 * - INSTRUMENT_ID_TYPE_TICKER: Ticker.
 * - INSTRUMENT_ID_TYPE_UID: Уникальный идентификатор.
 * - INSTRUMENT_ID_TYPE_POSITION_UID: Идентификатор позиции.
 */
export const zV1InstrumentIdType = z
    .enum([
        'INSTRUMENT_ID_UNSPECIFIED',
        'INSTRUMENT_ID_TYPE_FIGI',
        'INSTRUMENT_ID_TYPE_TICKER',
        'INSTRUMENT_ID_TYPE_UID',
        'INSTRUMENT_ID_TYPE_POSITION_UID',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип идентификатора инструмента. [Подробнее об идентификации инструментов](./faq_identification/).\n\n - INSTRUMENT_ID_UNSPECIFIED: Значение не определено.\n - INSTRUMENT_ID_TYPE_FIGI: FIGI.\n - INSTRUMENT_ID_TYPE_TICKER: Ticker.\n - INSTRUMENT_ID_TYPE_UID: Уникальный идентификатор.\n - INSTRUMENT_ID_TYPE_POSITION_UID: Идентификатор позиции.',
    });

/**
 * Связь с другим инструментом.
 */
export const zV1InstrumentLink = z
    .object({
        type: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип связи.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID-идентификатор связанного инструмента.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Связь с другим инструментом.',
    });

/**
 * Запрос получения инструмента по идентификатору.
 */
export const zV1InstrumentRequest = z
    .object({
        idType: zV1InstrumentIdType,
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор `class_code`. Обязательный, если `id_type = ticker`.',
            }),
        ),
        id: z.string().register(z.globalRegistry, {
            description: 'Идентификатор запрашиваемого инструмента.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения инструмента по идентификатору.',
    });

/**
 * Статус запрашиваемых инструментов.
 *
 * - INSTRUMENT_STATUS_UNSPECIFIED: Значение не определено.
 * - INSTRUMENT_STATUS_BASE: По умолчанию — базовый список инструментов, которыми можно торговать через T-Invest API. Сейчас списки доступных бумаг в API и других интерфейсах совпадают — кроме внебиржевых бумаг, но в будущем списки могут различаться.
 * - INSTRUMENT_STATUS_ALL: Список всех инструментов.
 */
export const zV1InstrumentStatus = z
    .enum(['INSTRUMENT_STATUS_UNSPECIFIED', 'INSTRUMENT_STATUS_BASE', 'INSTRUMENT_STATUS_ALL'])
    .register(z.globalRegistry, {
        description:
            'Статус запрашиваемых инструментов.\n\n - INSTRUMENT_STATUS_UNSPECIFIED: Значение не определено.\n - INSTRUMENT_STATUS_BASE: По умолчанию — базовый список инструментов, которыми можно торговать через T-Invest API. Сейчас списки доступных бумаг в API и других интерфейсах совпадают — кроме внебиржевых бумаг, но в будущем списки могут различаться.\n - INSTRUMENT_STATUS_ALL: Список всех инструментов.',
    });

/**
 * Запрос цен закрытия торговой сессии по инструментам.
 */
export const zV1GetClosePricesRequest = z
    .object({
        instruments: z.array(zV1InstrumentClosePriceRequest).register(z.globalRegistry, {
            description: 'Массив по инструментам.',
        }),
        instrumentStatus: z.optional(zV1InstrumentStatus),
    })
    .register(z.globalRegistry, {
        description: 'Запрос цен закрытия торговой сессии по инструментам.',
    });

/**
 * Тип инструмента.
 *
 * - INSTRUMENT_TYPE_BOND: Облигация.
 * - INSTRUMENT_TYPE_SHARE: Акция.
 * - INSTRUMENT_TYPE_CURRENCY: Валюта.
 * - INSTRUMENT_TYPE_ETF: Exchange-traded fund. Фонд.
 * - INSTRUMENT_TYPE_FUTURES: Фьючерс.
 * - INSTRUMENT_TYPE_SP: Структурная нота.
 * - INSTRUMENT_TYPE_OPTION: Опцион.
 * - INSTRUMENT_TYPE_CLEARING_CERTIFICATE: Clearing certificate.
 * - INSTRUMENT_TYPE_INDEX: Индекс.
 * - INSTRUMENT_TYPE_COMMODITY: Товар.
 */
export const zV1InstrumentType = z
    .enum([
        'INSTRUMENT_TYPE_UNSPECIFIED',
        'INSTRUMENT_TYPE_BOND',
        'INSTRUMENT_TYPE_SHARE',
        'INSTRUMENT_TYPE_CURRENCY',
        'INSTRUMENT_TYPE_ETF',
        'INSTRUMENT_TYPE_FUTURES',
        'INSTRUMENT_TYPE_SP',
        'INSTRUMENT_TYPE_OPTION',
        'INSTRUMENT_TYPE_CLEARING_CERTIFICATE',
        'INSTRUMENT_TYPE_INDEX',
        'INSTRUMENT_TYPE_COMMODITY',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип инструмента.\n\n - INSTRUMENT_TYPE_BOND: Облигация.\n - INSTRUMENT_TYPE_SHARE: Акция.\n - INSTRUMENT_TYPE_CURRENCY: Валюта.\n - INSTRUMENT_TYPE_ETF: Exchange-traded fund. Фонд.\n - INSTRUMENT_TYPE_FUTURES: Фьючерс.\n - INSTRUMENT_TYPE_SP: Структурная нота.\n - INSTRUMENT_TYPE_OPTION: Опцион.\n - INSTRUMENT_TYPE_CLEARING_CERTIFICATE: Clearing certificate.\n - INSTRUMENT_TYPE_INDEX: Индекс.\n - INSTRUMENT_TYPE_COMMODITY: Товар.',
    });

/**
 * Идентификаторы инструмента.
 */
export const zV1AssetInstrument = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID-идентификатор инструмента.',
            }),
        ),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        links: z.optional(
            z.array(zV1InstrumentLink).register(z.globalRegistry, {
                description: 'Массив связанных инструментов.',
            }),
        ),
        instrumentKind: z.optional(zV1InstrumentType),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ID позиции.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Идентификаторы инструмента.',
    });

/**
 * Информация об активе.
 */
export const zV1Asset = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор актива.',
            }),
        ),
        type: z.optional(zV1AssetType),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование актива.',
            }),
        ),
        instruments: z.optional(
            z.array(zV1AssetInstrument).register(z.globalRegistry, {
                description: 'Массив идентификаторов инструментов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация об активе.',
    });

/**
 * Запрос списка активов.
 */
export const zV1AssetsRequest = z
    .object({
        instrumentType: z.optional(zV1InstrumentType),
        instrumentStatus: z.optional(zV1InstrumentStatus),
    })
    .register(z.globalRegistry, {
        description: 'Запрос списка активов.',
    });

/**
 * Список активов.
 */
export const zV1AssetsResponse = z
    .object({
        assets: z.optional(
            z.array(zV1Asset).register(z.globalRegistry, {
                description: 'Активы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список активов.',
    });

/**
 * Массив избранных инструментов.
 */
export const zV1FavoriteInstrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код инструмента.',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Возможность торговать инструментом через API.',
            }),
        ),
        instrumentKind: z.optional(zV1InstrumentType),
    })
    .register(z.globalRegistry, {
        description: 'Массив избранных инструментов.',
    });

/**
 * Результат редактирования списка избранных инструментов.
 */
export const zV1EditFavoritesResponse = z
    .object({
        favoriteInstruments: z.optional(
            z.array(zV1FavoriteInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов.',
            }),
        ),
        groupId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор группы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат редактирования списка избранных инструментов.',
    });

/**
 * Запрос на поиск инструментов.
 */
export const zV1FindInstrumentRequest = z
    .object({
        query: z.string().register(z.globalRegistry, {
            description: 'Строка поиска.',
        }),
        instrumentKind: z.optional(zV1InstrumentType),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Фильтр для отображения только торговых инструментов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос на поиск инструментов.',
    });

/**
 * В ответ передается список избранных инструментов в качестве массива.
 */
export const zV1GetFavoritesResponse = z
    .object({
        favoriteInstruments: z.optional(
            z.array(zV1FavoriteInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов.',
            }),
        ),
        groupId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор группы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'В ответ передается список избранных инструментов в качестве массива.',
    });

/**
 * Индикатив
 */
export const zV1IndicativeResponse = z.object({
    figi: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'FIGI-идентификатор инструмента.',
        }),
    ),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    classCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Класс-код инструмента.',
        }),
    ),
    currency: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Валюта расчетов.',
        }),
    ),
    instrumentKind: z.optional(zV1InstrumentType),
    name: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Название инструмента.',
        }),
    ),
    exchange: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Tорговая площадка (секция биржи).',
        }),
    ),
    uid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор инструмента.',
        }),
    ),
    buyAvailableFlag: z.optional(
        z.boolean().register(z.globalRegistry, {
            description: 'Признак доступности для покупки.',
        }),
    ),
    sellAvailableFlag: z.optional(
        z.boolean().register(z.globalRegistry, {
            description: 'Признак доступности для продажи.',
        }),
    ),
});

/**
 * Справочник индексов и товаров
 */
export const zV1IndicativesResponse = z.object({
    instruments: z.optional(
        z.array(zV1IndicativeResponse).register(z.globalRegistry, {
            description: 'Массив инструментов.',
        }),
    ),
});

/**
 * Краткая информация об инструменте.
 */
export const zV1InstrumentShort = z
    .object({
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN инструмента.',
            }),
        ),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Ticker инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ClassCode инструмента.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        instrumentKind: z.optional(zV1InstrumentType),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Возможность торговать инструментом через API.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Количество бумаг в лоте.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Краткая информация об инструменте.',
    });

/**
 * Результат поиска инструментов.
 */
export const zV1FindInstrumentResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1InstrumentShort).register(z.globalRegistry, {
                description: 'Массив инструментов, удовлетворяющих условиям поиска.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат поиска инструментов.',
    });

/**
 * Запрос получения инструментов.
 */
export const zV1InstrumentsRequest = z
    .object({
        instrumentStatus: z.optional(zV1InstrumentStatus),
        instrumentExchange: z.optional(zV1InstrumentExchangeType),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения инструментов.',
    });

/**
 * Запрос подписки на последнюю цену.
 */
export const zV1LastPriceInstrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.',
            }),
        ),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос подписки на последнюю цену.',
    });

/**
 * Тип последней цены
 *
 * - LAST_PRICE_UNSPECIFIED: Не определен.
 * - LAST_PRICE_EXCHANGE: Цена биржи.
 * - LAST_PRICE_DEALER: Цена дилера
 */
export const zV1LastPriceType = z
    .enum(['LAST_PRICE_UNSPECIFIED', 'LAST_PRICE_EXCHANGE', 'LAST_PRICE_DEALER'])
    .register(z.globalRegistry, {
        description:
            '- LAST_PRICE_UNSPECIFIED: Не определен.\n - LAST_PRICE_EXCHANGE: Цена биржи.\n - LAST_PRICE_DEALER: Цена дилера',
    });

/**
 * Запрос получения цен последних сделок.
 */
export const zV1GetLastPricesRequest = z
    .object({
        instrumentId: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    "Массив идентификаторов инструмента. Принимает значения `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
        lastPriceType: z.optional(zV1LastPriceType),
        instrumentStatus: z.optional(zV1InstrumentStatus),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения цен последних сделок.',
    });

/**
 * - INSTRUMENT_VALUE_UNSPECIFIED: Не определен.
 * - INSTRUMENT_VALUE_LAST_PRICE: Последняя биржевая цена.
 * - INSTRUMENT_VALUE_LAST_PRICE_DEALER: Последняя цена дилера.
 * - INSTRUMENT_VALUE_CLOSE_PRICE: Цена закрытия.
 * - INSTRUMENT_VALUE_EVENING_SESSION_PRICE: Цена последней сделки с вечерней сессии.
 * - INSTRUMENT_VALUE_OPEN_INTEREST: Открытый интерес, возвращается только для фьючерсов.
 * - INSTRUMENT_VALUE_THEOR_PRICE: Теоретическая цена, возвращается только для опционов.
 * - INSTRUMENT_VALUE_YIELD: Доходность
 */
export const zV1MarketValueType = z.enum([
    'INSTRUMENT_VALUE_UNSPECIFIED',
    'INSTRUMENT_VALUE_LAST_PRICE',
    'INSTRUMENT_VALUE_LAST_PRICE_DEALER',
    'INSTRUMENT_VALUE_CLOSE_PRICE',
    'INSTRUMENT_VALUE_EVENING_SESSION_PRICE',
    'INSTRUMENT_VALUE_OPEN_INTEREST',
    'INSTRUMENT_VALUE_THEOR_PRICE',
    'INSTRUMENT_VALUE_YIELD',
]);

export const zV1GetMarketValuesRequest = z.object({
    instrumentId: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description:
                "Массив идентификаторов инструментов. Принимает значения `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
        }),
    ),
    values: z.optional(
        z.array(zV1MarketValueType).register(z.globalRegistry, {
            description: 'Массив запрашиваемых параметров.',
        }),
    ),
});

/**
 * Денежная сумма в определенной валюте.
 */
export const zV1MoneyValue = z
    .object({
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Строковый ISO-код валюты.',
            }),
        ),
        units: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Целая часть суммы, может быть отрицательным числом.',
            }),
        ),
        nano: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Дробная часть суммы, может быть отрицательным числом.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Денежная сумма в определенной валюте.',
    });

export const zGetOrderPriceResponseExtraFuture = z.object({
    initialMargin: z.optional(zV1MoneyValue),
});

/**
 * Банковский счeт.
 */
export const zV1BankAccount = z
    .object({
        id: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счeта.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название счeта.',
            }),
        ),
        money: z.optional(
            z.array(zV1MoneyValue).register(z.globalRegistry, {
                description: 'Список валютных позиций на счeте.',
            }),
        ),
        openedDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата открытия счeта в часовом поясе UTC.',
            }),
        ),
        type: z.optional(zV1AccountType),
    })
    .register(z.globalRegistry, {
        description: 'Банковский счeт.',
    });

export const zV1ChildOperationItem = z.object({
    instrumentUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор инструмента.',
        }),
    ),
    payment: z.optional(zV1MoneyValue),
});

/**
 * Объект передачи информации о купоне облигации.
 */
export const zV1Coupon = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        couponDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата выплаты купона.',
            }),
        ),
        couponNumber: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Номер купона.',
            }),
        ),
        fixDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата фиксации реестра для выплаты купона — опционально.',
            }),
        ),
        payOneBond: z.optional(zV1MoneyValue),
        couponType: z.optional(zV1CouponType),
        couponStartDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Начало купонного периода.',
            }),
        ),
        couponEndDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Окончание купонного периода.',
            }),
        ),
        couponPeriod: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Купонный период в днях.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации о купоне облигации.',
    });

export const zV1CurrencyTransferRequest = z.object({
    fromAccountId: z.string().register(z.globalRegistry, {
        description: 'Номер счета списания.',
    }),
    toAccountId: z.string().register(z.globalRegistry, {
        description: 'Номер счета зачисления.',
    }),
    amount: zV1MoneyValue,
    transactionId: z.optional(
        z.string().register(z.globalRegistry, {
            description:
                'Идентификатор запроса выставления поручения для целей идемпотентности в формате UUID.',
        }),
    ),
});

/**
 * Список банковских счетов пользователя.
 */
export const zV1GetBankAccountsResponse = z
    .object({
        bankAccounts: z.optional(
            z.array(zV1BankAccount).register(z.globalRegistry, {
                description: 'Массив банковских счетов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список банковских счетов пользователя.',
    });

/**
 * Купоны по облигации.
 */
export const zV1GetBondCouponsResponse = z
    .object({
        events: z.optional(z.array(zV1Coupon)),
    })
    .register(z.globalRegistry, {
        description: 'Купоны по облигации.',
    });

export const zV1OpenInterest = z.object({
    instrumentUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'UID инструмента.',
        }),
    ),
    time: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Время получения открытого интереса в часовом поясе UTC по времени биржи.',
        }),
    ),
    openInterest: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Открытый интерес.',
        }),
    ),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    classCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Класс-код (секция торгов).',
        }),
    ),
});

/**
 * Запрос открытия счета в песочнице.
 */
export const zV1OpenSandboxAccountRequest = z
    .object({
        name: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Запрос открытия счета в песочнице.',
    });

/**
 * Номер открытого счета в песочнице.
 */
export const zV1OpenSandboxAccountResponse = z
    .object({
        accountId: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Номер открытого счета в песочнице.',
    });

/**
 * Статус запрашиваемых операций.
 *
 * - OPERATION_STATE_UNSPECIFIED: Статус операции не определен.
 * - OPERATION_STATE_EXECUTED: Исполнена частично или полностью.
 * - OPERATION_STATE_CANCELED: Отменена.
 * - OPERATION_STATE_PROGRESS: Исполняется.
 */
export const zV1OperationState = z
    .enum([
        'OPERATION_STATE_UNSPECIFIED',
        'OPERATION_STATE_EXECUTED',
        'OPERATION_STATE_CANCELED',
        'OPERATION_STATE_PROGRESS',
    ])
    .register(z.globalRegistry, {
        description:
            'Статус запрашиваемых операций.\n\n - OPERATION_STATE_UNSPECIFIED: Статус операции не определен.\n - OPERATION_STATE_EXECUTED: Исполнена частично или полностью.\n - OPERATION_STATE_CANCELED: Отменена.\n - OPERATION_STATE_PROGRESS: Исполняется.',
    });

/**
 * Сделка по операции.
 */
export const zV1OperationTrade = z
    .object({
        tradeId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор сделки.',
            }),
        ),
        dateTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время сделки по UTC.',
            }),
        ),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество инструментов.',
            }),
        ),
        price: z.optional(zV1MoneyValue),
    })
    .register(z.globalRegistry, {
        description: 'Сделка по операции.',
    });

/**
 * Тип операции.
 *
 * - OPERATION_TYPE_UNSPECIFIED: Тип операции не определен.
 * - OPERATION_TYPE_INPUT: Пополнение брокерского счета.
 * - OPERATION_TYPE_BOND_TAX: Удержание НДФЛ по купонам.
 * - OPERATION_TYPE_OUTPUT_SECURITIES: Вывод ЦБ.
 * - OPERATION_TYPE_OVERNIGHT: Доход по сделке РЕПО овернайт.
 * - OPERATION_TYPE_TAX: Удержание налога.
 * - OPERATION_TYPE_BOND_REPAYMENT_FULL: Полное погашение облигаций.
 * - OPERATION_TYPE_SELL_CARD: Продажа ЦБ с карты.
 * - OPERATION_TYPE_DIVIDEND_TAX: Удержание налога по дивидендам.
 * - OPERATION_TYPE_OUTPUT: Вывод денежных средств.
 * - OPERATION_TYPE_BOND_REPAYMENT: Частичное погашение облигаций.
 * - OPERATION_TYPE_TAX_CORRECTION: Корректировка налога.
 * - OPERATION_TYPE_SERVICE_FEE: Удержание комиссии за обслуживание брокерского счета.
 * - OPERATION_TYPE_BENEFIT_TAX: Удержание налога за материальную выгоду.
 * - OPERATION_TYPE_MARGIN_FEE: Удержание комиссии за непокрытую позицию.
 * - OPERATION_TYPE_BUY: Покупка ЦБ.
 * - OPERATION_TYPE_BUY_CARD: Покупка ЦБ с карты.
 * - OPERATION_TYPE_INPUT_SECURITIES: Перевод ценных бумаг из другого депозитария.
 * - OPERATION_TYPE_SELL_MARGIN: Продажа в результате Margin-call.
 * - OPERATION_TYPE_BROKER_FEE: Удержание комиссии за операцию.
 * - OPERATION_TYPE_BUY_MARGIN: Покупка в результате Margin-call.
 * - OPERATION_TYPE_DIVIDEND: Выплата дивидендов.
 * - OPERATION_TYPE_SELL: Продажа ЦБ.
 * - OPERATION_TYPE_COUPON: Выплата купонов.
 * - OPERATION_TYPE_SUCCESS_FEE: Удержание комиссии SuccessFee.
 * - OPERATION_TYPE_DIVIDEND_TRANSFER: Передача дивидендного дохода.
 * - OPERATION_TYPE_ACCRUING_VARMARGIN: Зачисление вариационной маржи.
 * - OPERATION_TYPE_WRITING_OFF_VARMARGIN: Списание вариационной маржи.
 * - OPERATION_TYPE_DELIVERY_BUY: Покупка в рамках экспирации фьючерсного контракта.
 * - OPERATION_TYPE_DELIVERY_SELL: Продажа в рамках экспирации фьючерсного контракта.
 * - OPERATION_TYPE_TRACK_MFEE: Комиссия за управление по счету автоследования.
 * - OPERATION_TYPE_TRACK_PFEE: Комиссия за результат по счету автоследования.
 * - OPERATION_TYPE_TAX_PROGRESSIVE: Удержание налога по ставке 15%.
 * - OPERATION_TYPE_BOND_TAX_PROGRESSIVE: Удержание налога по купонам по ставке 15%.
 * - OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE: Удержание налога по дивидендам по ставке 15%.
 * - OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE: Удержание налога за материальную выгоду по ставке 15%.
 * - OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE: Корректировка налога по ставке 15%.
 * - OPERATION_TYPE_TAX_REPO_PROGRESSIVE: Удержание налога за возмещение по сделкам РЕПО по ставке 15%.
 * - OPERATION_TYPE_TAX_REPO: Удержание налога за возмещение по сделкам РЕПО.
 * - OPERATION_TYPE_TAX_REPO_HOLD: Удержание налога по сделкам РЕПО.
 * - OPERATION_TYPE_TAX_REPO_REFUND: Возврат налога по сделкам РЕПО.
 * - OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE: Удержание налога по сделкам РЕПО по ставке 15%.
 * - OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE: Возврат налога по сделкам РЕПО по ставке 15%.
 * - OPERATION_TYPE_DIV_EXT: Выплата дивидендов на карту.
 * - OPERATION_TYPE_TAX_CORRECTION_COUPON: Корректировка налога по купонам.
 * - OPERATION_TYPE_CASH_FEE: Комиссия за валютный остаток.
 * - OPERATION_TYPE_OUT_FEE: Комиссия за вывод валюты с брокерского счета.
 * - OPERATION_TYPE_OUT_STAMP_DUTY: Гербовый сбор.
 * - OPERATION_TYPE_OUTPUT_SWIFT: SWIFT-перевод.
 * - OPERATION_TYPE_INPUT_SWIFT: SWIFT-перевод.
 * - OPERATION_TYPE_OUTPUT_ACQUIRING: Перевод на карту.
 * - OPERATION_TYPE_INPUT_ACQUIRING: Перевод с карты.
 * - OPERATION_TYPE_OUTPUT_PENALTY: Комиссия за вывод средств.
 * - OPERATION_TYPE_ADVICE_FEE: Списание оплаты за сервис Советов.
 * - OPERATION_TYPE_TRANS_IIS_BS: Перевод ценных бумаг с ИИС на брокерский счет.
 * - OPERATION_TYPE_TRANS_BS_BS: Перевод ценных бумаг с одного брокерского счета на другой.
 * - OPERATION_TYPE_OUT_MULTI: Вывод денежных средств со счета.
 * - OPERATION_TYPE_INP_MULTI: Пополнение денежных средств со счета.
 * - OPERATION_TYPE_OVER_PLACEMENT: Размещение биржевого овернайта.
 * - OPERATION_TYPE_OVER_COM: Списание комиссии.
 * - OPERATION_TYPE_OVER_INCOME: Доход от оверанайта.
 * - OPERATION_TYPE_OPTION_EXPIRATION: Экспирация опциона.
 * - OPERATION_TYPE_FUTURE_EXPIRATION: Экспирация фьючерса.
 */
export const zV1OperationType = z
    .enum([
        'OPERATION_TYPE_UNSPECIFIED',
        'OPERATION_TYPE_INPUT',
        'OPERATION_TYPE_BOND_TAX',
        'OPERATION_TYPE_OUTPUT_SECURITIES',
        'OPERATION_TYPE_OVERNIGHT',
        'OPERATION_TYPE_TAX',
        'OPERATION_TYPE_BOND_REPAYMENT_FULL',
        'OPERATION_TYPE_SELL_CARD',
        'OPERATION_TYPE_DIVIDEND_TAX',
        'OPERATION_TYPE_OUTPUT',
        'OPERATION_TYPE_BOND_REPAYMENT',
        'OPERATION_TYPE_TAX_CORRECTION',
        'OPERATION_TYPE_SERVICE_FEE',
        'OPERATION_TYPE_BENEFIT_TAX',
        'OPERATION_TYPE_MARGIN_FEE',
        'OPERATION_TYPE_BUY',
        'OPERATION_TYPE_BUY_CARD',
        'OPERATION_TYPE_INPUT_SECURITIES',
        'OPERATION_TYPE_SELL_MARGIN',
        'OPERATION_TYPE_BROKER_FEE',
        'OPERATION_TYPE_BUY_MARGIN',
        'OPERATION_TYPE_DIVIDEND',
        'OPERATION_TYPE_SELL',
        'OPERATION_TYPE_COUPON',
        'OPERATION_TYPE_SUCCESS_FEE',
        'OPERATION_TYPE_DIVIDEND_TRANSFER',
        'OPERATION_TYPE_ACCRUING_VARMARGIN',
        'OPERATION_TYPE_WRITING_OFF_VARMARGIN',
        'OPERATION_TYPE_DELIVERY_BUY',
        'OPERATION_TYPE_DELIVERY_SELL',
        'OPERATION_TYPE_TRACK_MFEE',
        'OPERATION_TYPE_TRACK_PFEE',
        'OPERATION_TYPE_TAX_PROGRESSIVE',
        'OPERATION_TYPE_BOND_TAX_PROGRESSIVE',
        'OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE',
        'OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE',
        'OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE',
        'OPERATION_TYPE_TAX_REPO_PROGRESSIVE',
        'OPERATION_TYPE_TAX_REPO',
        'OPERATION_TYPE_TAX_REPO_HOLD',
        'OPERATION_TYPE_TAX_REPO_REFUND',
        'OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE',
        'OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE',
        'OPERATION_TYPE_DIV_EXT',
        'OPERATION_TYPE_TAX_CORRECTION_COUPON',
        'OPERATION_TYPE_CASH_FEE',
        'OPERATION_TYPE_OUT_FEE',
        'OPERATION_TYPE_OUT_STAMP_DUTY',
        'OPERATION_TYPE_OUTPUT_SWIFT',
        'OPERATION_TYPE_INPUT_SWIFT',
        'OPERATION_TYPE_OUTPUT_ACQUIRING',
        'OPERATION_TYPE_INPUT_ACQUIRING',
        'OPERATION_TYPE_OUTPUT_PENALTY',
        'OPERATION_TYPE_ADVICE_FEE',
        'OPERATION_TYPE_TRANS_IIS_BS',
        'OPERATION_TYPE_TRANS_BS_BS',
        'OPERATION_TYPE_OUT_MULTI',
        'OPERATION_TYPE_INP_MULTI',
        'OPERATION_TYPE_OVER_PLACEMENT',
        'OPERATION_TYPE_OVER_COM',
        'OPERATION_TYPE_OVER_INCOME',
        'OPERATION_TYPE_OPTION_EXPIRATION',
        'OPERATION_TYPE_FUTURE_EXPIRATION',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип операции.\n\n - OPERATION_TYPE_UNSPECIFIED: Тип операции не определен.\n - OPERATION_TYPE_INPUT: Пополнение брокерского счета.\n - OPERATION_TYPE_BOND_TAX: Удержание НДФЛ по купонам.\n - OPERATION_TYPE_OUTPUT_SECURITIES: Вывод ЦБ.\n - OPERATION_TYPE_OVERNIGHT: Доход по сделке РЕПО овернайт.\n - OPERATION_TYPE_TAX: Удержание налога.\n - OPERATION_TYPE_BOND_REPAYMENT_FULL: Полное погашение облигаций.\n - OPERATION_TYPE_SELL_CARD: Продажа ЦБ с карты.\n - OPERATION_TYPE_DIVIDEND_TAX: Удержание налога по дивидендам.\n - OPERATION_TYPE_OUTPUT: Вывод денежных средств.\n - OPERATION_TYPE_BOND_REPAYMENT: Частичное погашение облигаций.\n - OPERATION_TYPE_TAX_CORRECTION: Корректировка налога.\n - OPERATION_TYPE_SERVICE_FEE: Удержание комиссии за обслуживание брокерского счета.\n - OPERATION_TYPE_BENEFIT_TAX: Удержание налога за материальную выгоду.\n - OPERATION_TYPE_MARGIN_FEE: Удержание комиссии за непокрытую позицию.\n - OPERATION_TYPE_BUY: Покупка ЦБ.\n - OPERATION_TYPE_BUY_CARD: Покупка ЦБ с карты.\n - OPERATION_TYPE_INPUT_SECURITIES: Перевод ценных бумаг из другого депозитария.\n - OPERATION_TYPE_SELL_MARGIN: Продажа в результате Margin-call.\n - OPERATION_TYPE_BROKER_FEE: Удержание комиссии за операцию.\n - OPERATION_TYPE_BUY_MARGIN: Покупка в результате Margin-call.\n - OPERATION_TYPE_DIVIDEND: Выплата дивидендов.\n - OPERATION_TYPE_SELL: Продажа ЦБ.\n - OPERATION_TYPE_COUPON: Выплата купонов.\n - OPERATION_TYPE_SUCCESS_FEE: Удержание комиссии SuccessFee.\n - OPERATION_TYPE_DIVIDEND_TRANSFER: Передача дивидендного дохода.\n - OPERATION_TYPE_ACCRUING_VARMARGIN: Зачисление вариационной маржи.\n - OPERATION_TYPE_WRITING_OFF_VARMARGIN: Списание вариационной маржи.\n - OPERATION_TYPE_DELIVERY_BUY: Покупка в рамках экспирации фьючерсного контракта.\n - OPERATION_TYPE_DELIVERY_SELL: Продажа в рамках экспирации фьючерсного контракта.\n - OPERATION_TYPE_TRACK_MFEE: Комиссия за управление по счету автоследования.\n - OPERATION_TYPE_TRACK_PFEE: Комиссия за результат по счету автоследования.\n - OPERATION_TYPE_TAX_PROGRESSIVE: Удержание налога по ставке 15%.\n - OPERATION_TYPE_BOND_TAX_PROGRESSIVE: Удержание налога по купонам по ставке 15%.\n - OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE: Удержание налога по дивидендам по ставке 15%.\n - OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE: Удержание налога за материальную выгоду по ставке 15%.\n - OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE: Корректировка налога по ставке 15%.\n - OPERATION_TYPE_TAX_REPO_PROGRESSIVE: Удержание налога за возмещение по сделкам РЕПО по ставке 15%.\n - OPERATION_TYPE_TAX_REPO: Удержание налога за возмещение по сделкам РЕПО.\n - OPERATION_TYPE_TAX_REPO_HOLD: Удержание налога по сделкам РЕПО.\n - OPERATION_TYPE_TAX_REPO_REFUND: Возврат налога по сделкам РЕПО.\n - OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE: Удержание налога по сделкам РЕПО по ставке 15%.\n - OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE: Возврат налога по сделкам РЕПО по ставке 15%.\n - OPERATION_TYPE_DIV_EXT: Выплата дивидендов на карту.\n - OPERATION_TYPE_TAX_CORRECTION_COUPON: Корректировка налога по купонам.\n - OPERATION_TYPE_CASH_FEE: Комиссия за валютный остаток.\n - OPERATION_TYPE_OUT_FEE: Комиссия за вывод валюты с брокерского счета.\n - OPERATION_TYPE_OUT_STAMP_DUTY: Гербовый сбор.\n - OPERATION_TYPE_OUTPUT_SWIFT: SWIFT-перевод.\n - OPERATION_TYPE_INPUT_SWIFT: SWIFT-перевод.\n - OPERATION_TYPE_OUTPUT_ACQUIRING: Перевод на карту.\n - OPERATION_TYPE_INPUT_ACQUIRING: Перевод с карты.\n - OPERATION_TYPE_OUTPUT_PENALTY: Комиссия за вывод средств.\n - OPERATION_TYPE_ADVICE_FEE: Списание оплаты за сервис Советов.\n - OPERATION_TYPE_TRANS_IIS_BS: Перевод ценных бумаг с ИИС на брокерский счет.\n - OPERATION_TYPE_TRANS_BS_BS: Перевод ценных бумаг с одного брокерского счета на другой.\n - OPERATION_TYPE_OUT_MULTI: Вывод денежных средств со счета.\n - OPERATION_TYPE_INP_MULTI: Пополнение денежных средств со счета.\n - OPERATION_TYPE_OVER_PLACEMENT: Размещение биржевого овернайта.\n - OPERATION_TYPE_OVER_COM: Списание комиссии.\n - OPERATION_TYPE_OVER_INCOME: Доход от оверанайта.\n - OPERATION_TYPE_OPTION_EXPIRATION: Экспирация опциона.\n - OPERATION_TYPE_FUTURE_EXPIRATION: Экспирация фьючерса.',
    });

/**
 * Запрос списка операций по счету с пагинацией.
 */
export const zV1GetOperationsByCursorRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description:
                'Идентификатор счета клиента, обязательный параметр. Остальные параметры опциональны.',
        }),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор инструмента — FIGI или UID инструмента.',
            }),
        ),
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Начало периода по UTC.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Окончание периода по UTC.',
            }),
        ),
        cursor: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор элемента, с которого начать формировать ответ.',
            }),
        ),
        limit: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Лимит количества операций. По умолчанию — `100`, максимальное значение — `1000`.',
            }),
        ),
        operationTypes: z.optional(
            z.array(zV1OperationType).register(z.globalRegistry, {
                description: 'Тип операции. Принимает значение из списка `OperationType`.',
            }),
        ),
        state: z.optional(zV1OperationState),
        withoutCommissions: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг возврата комиссии. По умолчанию — `false`.',
            }),
        ),
        withoutTrades: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг получения ответа без массива сделок.',
            }),
        ),
        withoutOvernights: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг показа overnight операций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос списка операций по счету с пагинацией.',
    });

/**
 * Данные по операции.
 */
export const zV1Operation = z
    .object({
        id: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор операции.',
            }),
        ),
        parentOperationId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор родительской операции.',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта операции.',
            }),
        ),
        payment: z.optional(zV1MoneyValue),
        price: z.optional(zV1MoneyValue),
        state: z.optional(zV1OperationState),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество единиц инструмента.',
            }),
        ),
        quantityRest: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Неисполненный остаток по сделке.',
            }),
        ),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента, связанного с операцией.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Тип инструмента. Возможные значения: <br/><br/>`bond` — облигация; <br/>`share` — акция; <br/>`currency` — валюта; <br/>`etf` — фонд; <br/>`futures` — фьючерс.',
            }),
        ),
        date: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время операции в формате часовом поясе UTC.',
            }),
        ),
        type: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Текстовое описание типа операции.',
            }),
        ),
        operationType: z.optional(zV1OperationType),
        trades: z.optional(
            z.array(zV1OperationTrade).register(z.globalRegistry, {
                description: 'Массив сделок.',
            }),
        ),
        assetUid: z.optional(z.string()),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        childOperations: z.optional(
            z.array(zV1ChildOperationItem).register(z.globalRegistry, {
                description: 'Массив дочерних операций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по операции.',
    });

/**
 * Запрос получения списка операций по счету.
 */
export const zV1OperationsRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета клиента.',
        }),
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Начало периода по UTC.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Окончание периода по UTC.',
            }),
        ),
        state: z.optional(zV1OperationState),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента для фильтрации.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения списка операций по счету.',
    });

/**
 * Список операций.
 */
export const zV1OperationsResponse = z
    .object({
        operations: z.optional(
            z.array(zV1Operation).register(z.globalRegistry, {
                description: 'Массив операций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список операций.',
    });

/**
 * Тип опциона по направлению сделки.
 *
 * - OPTION_DIRECTION_UNSPECIFIED: Тип не определен.
 * - OPTION_DIRECTION_PUT: Опцион на продажу.
 * - OPTION_DIRECTION_CALL: Опцион на покупку.
 */
export const zV1OptionDirection = z
    .enum(['OPTION_DIRECTION_UNSPECIFIED', 'OPTION_DIRECTION_PUT', 'OPTION_DIRECTION_CALL'])
    .register(z.globalRegistry, {
        description:
            'Тип опциона по направлению сделки.\n\n - OPTION_DIRECTION_UNSPECIFIED: Тип не определен.\n - OPTION_DIRECTION_PUT: Опцион на продажу.\n - OPTION_DIRECTION_CALL: Опцион на покупку.',
    });

/**
 * Тип расчетов по опциону.
 *
 * - OPTION_PAYMENT_TYPE_UNSPECIFIED: Тип не определен.
 * - OPTION_PAYMENT_TYPE_PREMIUM: Опционы с использованием премии в расчетах.
 * - OPTION_PAYMENT_TYPE_MARGINAL: Маржируемые опционы.
 */
export const zV1OptionPaymentType = z
    .enum([
        'OPTION_PAYMENT_TYPE_UNSPECIFIED',
        'OPTION_PAYMENT_TYPE_PREMIUM',
        'OPTION_PAYMENT_TYPE_MARGINAL',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип расчетов по опциону.\n\n - OPTION_PAYMENT_TYPE_UNSPECIFIED: Тип не определен.\n - OPTION_PAYMENT_TYPE_PREMIUM: Опционы с использованием премии в расчетах.\n - OPTION_PAYMENT_TYPE_MARGINAL: Маржируемые опционы.',
    });

/**
 * Тип опциона по способу исполнения.
 *
 * - OPTION_EXECUTION_TYPE_UNSPECIFIED: Тип не определен.
 * - OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY: Поставочный тип опциона.
 * - OPTION_EXECUTION_TYPE_CASH_SETTLEMENT: Расчетный тип опциона.
 */
export const zV1OptionSettlementType = z
    .enum([
        'OPTION_EXECUTION_TYPE_UNSPECIFIED',
        'OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY',
        'OPTION_EXECUTION_TYPE_CASH_SETTLEMENT',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип опциона по способу исполнения.\n\n - OPTION_EXECUTION_TYPE_UNSPECIFIED: Тип не определен.\n - OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY: Поставочный тип опциона.\n - OPTION_EXECUTION_TYPE_CASH_SETTLEMENT: Расчетный тип опциона.',
    });

/**
 * Тип опциона по стилю.
 *
 * - OPTION_STYLE_UNSPECIFIED: Тип не определен.
 * - OPTION_STYLE_AMERICAN: Американский опцион.
 * - OPTION_STYLE_EUROPEAN: Европейский опцион.
 */
export const zV1OptionStyle = z
    .enum(['OPTION_STYLE_UNSPECIFIED', 'OPTION_STYLE_AMERICAN', 'OPTION_STYLE_EUROPEAN'])
    .register(z.globalRegistry, {
        description:
            'Тип опциона по стилю.\n\n - OPTION_STYLE_UNSPECIFIED: Тип не определен.\n - OPTION_STYLE_AMERICAN: Американский опцион.\n - OPTION_STYLE_EUROPEAN: Европейский опцион.',
    });

/**
 *  - ORDERBOOK_TYPE_UNSPECIFIED: Не определен.
 * - ORDERBOOK_TYPE_EXCHANGE: Биржевой стакан.
 * - ORDERBOOK_TYPE_DEALER: Стакан дилера.
 * - ORDERBOOK_TYPE_ALL: Стакан биржевой и дилера.
 */
export const zV1OrderBookType = z
    .enum([
        'ORDERBOOK_TYPE_UNSPECIFIED',
        'ORDERBOOK_TYPE_EXCHANGE',
        'ORDERBOOK_TYPE_DEALER',
        'ORDERBOOK_TYPE_ALL',
    ])
    .register(z.globalRegistry, {
        description:
            ' - ORDERBOOK_TYPE_UNSPECIFIED: Не определен.\n - ORDERBOOK_TYPE_EXCHANGE: Биржевой стакан.\n - ORDERBOOK_TYPE_DEALER: Стакан дилера.\n - ORDERBOOK_TYPE_ALL: Стакан биржевой и дилера.',
    });

/**
 * Запрос подписки на стаканы.
 */
export const zV1OrderBookInstrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.',
            }),
        ),
        depth: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Глубина стакана.',
            }),
        ),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
        orderBookType: z.optional(zV1OrderBookType),
    })
    .register(z.globalRegistry, {
        description: 'Запрос подписки на стаканы.',
    });

/**
 * Направление операции.
 *
 * - ORDER_DIRECTION_UNSPECIFIED: Значение не указано
 * - ORDER_DIRECTION_BUY: Покупка
 * - ORDER_DIRECTION_SELL: Продажа
 */
export const zV1OrderDirection = z
    .enum(['ORDER_DIRECTION_UNSPECIFIED', 'ORDER_DIRECTION_BUY', 'ORDER_DIRECTION_SELL'])
    .register(z.globalRegistry, {
        description:
            'Направление операции.\n\n - ORDER_DIRECTION_UNSPECIFIED: Значение не указано\n - ORDER_DIRECTION_BUY: Покупка\n - ORDER_DIRECTION_SELL: Продажа',
    });

/**
 * Текущий статус заявки (поручения)
 *
 * - EXECUTION_REPORT_STATUS_FILL: Исполнена
 * - EXECUTION_REPORT_STATUS_REJECTED: Отклонена
 * - EXECUTION_REPORT_STATUS_CANCELLED: Отменена пользователем
 * - EXECUTION_REPORT_STATUS_NEW: Новая
 * - EXECUTION_REPORT_STATUS_PARTIALLYFILL: Частично исполнена
 */
export const zV1OrderExecutionReportStatus = z
    .enum([
        'EXECUTION_REPORT_STATUS_UNSPECIFIED',
        'EXECUTION_REPORT_STATUS_FILL',
        'EXECUTION_REPORT_STATUS_REJECTED',
        'EXECUTION_REPORT_STATUS_CANCELLED',
        'EXECUTION_REPORT_STATUS_NEW',
        'EXECUTION_REPORT_STATUS_PARTIALLYFILL',
    ])
    .register(z.globalRegistry, {
        description:
            '- EXECUTION_REPORT_STATUS_FILL: Исполнена\n - EXECUTION_REPORT_STATUS_REJECTED: Отклонена\n - EXECUTION_REPORT_STATUS_CANCELLED: Отменена пользователем\n - EXECUTION_REPORT_STATUS_NEW: Новая\n - EXECUTION_REPORT_STATUS_PARTIALLYFILL: Частично исполнена',
    });

export const zGetOrdersRequestGetOrdersRequestFilters = z.object({
    from: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description:
                'Дата и время, начиная с которой нужно получить информацию в часовом поясе UTC. Параметр применим только к ордерам, созданным сегодня.',
        }),
    ),
    to: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description:
                'Дата и время, до которой нужно получить информацию в часовом поясе UTC. Параметр применим только к ордерам, созданным сегодня.',
        }),
    ),
    executionStatus: z.optional(
        z.array(zV1OrderExecutionReportStatus).register(z.globalRegistry, {
            description: 'Статусы заявок.',
        }),
    ),
});

/**
 * Запрос получения списка активных торговых поручений.
 */
export const zV1GetOrdersRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        advancedFilters: z.optional(zGetOrdersRequestGetOrdersRequestFilters),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения списка активных торговых поручений.',
    });

/**
 * Тип идентификатора заявки
 *
 * - ORDER_ID_TYPE_UNSPECIFIED: Тип идентификатора не указан.
 * - ORDER_ID_TYPE_EXCHANGE: Биржевой идентификатор
 * - ORDER_ID_TYPE_REQUEST: Ключ идемпотентности, переданный клиентом
 */
export const zV1OrderIdType = z
    .enum(['ORDER_ID_TYPE_UNSPECIFIED', 'ORDER_ID_TYPE_EXCHANGE', 'ORDER_ID_TYPE_REQUEST'])
    .register(z.globalRegistry, {
        description:
            '- ORDER_ID_TYPE_UNSPECIFIED: Тип идентификатора не указан.\n - ORDER_ID_TYPE_EXCHANGE: Биржевой идентификатор\n - ORDER_ID_TYPE_REQUEST: Ключ идемпотентности, переданный клиентом',
    });

/**
 * Запрос отмены торгового поручения.
 */
export const zV1CancelOrderRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        orderId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор заявки.',
        }),
        orderIdType: z.optional(zV1OrderIdType),
    })
    .register(z.globalRegistry, {
        description: 'Запрос отмены торгового поручения.',
    });

/**
 * Сделки в рамках торгового поручения.
 */
export const zV1OrderStage = z
    .object({
        price: z.optional(zV1MoneyValue),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество лотов.',
            }),
        ),
        tradeId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор сделки.',
            }),
        ),
        executionTime: z.optional(z.iso.datetime()),
    })
    .register(z.globalRegistry, {
        description: 'Сделки в рамках торгового поручения.',
    });

/**
 * Запрос установки стрим-соединения торговых поручений
 */
export const zV1OrderStateStreamRequest = z.object({
    accounts: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description: 'Идентификаторы счетов.',
        }),
    ),
    pingDelayMillis: z.optional(
        z.int().register(z.globalRegistry, {
            description:
                'Задержка (пинг) сообщений:  1000-120 000 миллисекунд. Значение по умолчанию — 120 000.',
        }),
    ),
});

/**
 * Тип заявки.
 *
 * - ORDER_TYPE_UNSPECIFIED: Значение не указано
 * - ORDER_TYPE_LIMIT: Лимитная
 * - ORDER_TYPE_MARKET: Рыночная
 * - ORDER_TYPE_BESTPRICE: Лучшая цена
 */
export const zV1OrderType = z
    .enum([
        'ORDER_TYPE_UNSPECIFIED',
        'ORDER_TYPE_LIMIT',
        'ORDER_TYPE_MARKET',
        'ORDER_TYPE_BESTPRICE',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип заявки.\n\n - ORDER_TYPE_UNSPECIFIED: Значение не указано\n - ORDER_TYPE_LIMIT: Лимитная\n - ORDER_TYPE_MARKET: Рыночная\n - ORDER_TYPE_BESTPRICE: Лучшая цена',
    });

/**
 * Информация о торговом поручении.
 */
export const zContractv1OrderState = z
    .object({
        orderId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Биржевой идентификатор заявки.',
            }),
        ),
        executionReportStatus: z.optional(zV1OrderExecutionReportStatus),
        lotsRequested: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Запрошено лотов.',
            }),
        ),
        lotsExecuted: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Исполнено лотов.',
            }),
        ),
        initialOrderPrice: z.optional(zV1MoneyValue),
        executedOrderPrice: z.optional(zV1MoneyValue),
        totalOrderAmount: z.optional(zV1MoneyValue),
        averagePositionPrice: z.optional(zV1MoneyValue),
        initialCommission: z.optional(zV1MoneyValue),
        executedCommission: z.optional(zV1MoneyValue),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Figi-идентификатор инструмента.',
            }),
        ),
        direction: z.optional(zV1OrderDirection),
        initialSecurityPrice: z.optional(zV1MoneyValue),
        stages: z.optional(
            z.array(zV1OrderStage).register(z.globalRegistry, {
                description: 'Стадии выполнения заявки.',
            }),
        ),
        serviceCommission: z.optional(zV1MoneyValue),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта заявки.',
            }),
        ),
        orderType: z.optional(zV1OrderType),
        orderDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время выставления заявки в часовом поясе UTC.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID идентификатор инструмента.',
            }),
        ),
        orderRequestId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о торговом поручении.',
    });

/**
 * Список активных торговых поручений.
 */
export const zV1GetOrdersResponse = z
    .object({
        orders: z.optional(
            z.array(zContractv1OrderState).register(z.globalRegistry, {
                description: 'Массив активных заявок.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список активных торговых поручений.',
    });

export const zV1Page = z.object({
    limit: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Максимальное число возвращаемых записей.',
        }),
    ),
    pageNumber: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Порядковый номер страницы, начиная с 0.',
        }),
    ),
});

/**
 * Запрос списка брендов.
 */
export const zV1GetBrandsRequest = z
    .object({
        paging: z.optional(zV1Page),
    })
    .register(z.globalRegistry, {
        description: 'Запрос списка брендов.',
    });

/**
 * Запрос консенсус-прогнозов
 */
export const zV1GetConsensusForecastsRequest = z.object({
    paging: z.optional(zV1Page),
});

export const zV1PageResponse = z.object({
    limit: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Максимальное число возвращаемых записей.',
        }),
    ),
    pageNumber: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Порядковый номер страницы, начиная с 0.',
        }),
    ),
    totalCount: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Общее количество записей.',
        }),
    ),
});

/**
 * Список брендов.
 */
export const zV1GetBrandsResponse = z
    .object({
        brands: z.optional(
            z.array(zV1Brand).register(z.globalRegistry, {
                description: 'Массив брендов.',
            }),
        ),
        paging: z.optional(zV1PageResponse),
    })
    .register(z.globalRegistry, {
        description: 'Список брендов.',
    });

/**
 * Проверка активности стрима.
 */
export const zV1Ping = z
    .object({
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время проверки.',
            }),
        ),
        streamId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор соединения.',
            }),
        ),
        pingRequestTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время формирования запроса.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Проверка активности стрима.',
    });

export const zV1PingDelaySettings = z.object({
    pingDelayMs: z.optional(
        z.int().register(z.globalRegistry, {
            description:
                'Задержка (пинг) сообщений:  5000–180 000 миллисекунд. Значение по умолчанию — 120 000.',
        }),
    ),
});

export const zV1PingRequest = z.object({
    time: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Время формирования запроса.',
        }),
    ),
});

/**
 * Запрос получения текущего портфеля по счету.
 */
export const zV1PortfolioRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета пользователя.',
        }),
        currency: z.optional(zPortfolioRequestCurrencyRequest),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения текущего портфеля по счету.',
    });

/**
 * Запрос установки stream-соединения.
 */
export const zV1PortfolioStreamRequest = z
    .object({
        accounts: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description: 'Массив идентификаторов счетов пользователя.',
            }),
        ),
        pingSettings: z.optional(zV1PingDelaySettings),
    })
    .register(z.globalRegistry, {
        description: 'Запрос установки stream-соединения.',
    });

/**
 * Результат подписки.
 *
 * - PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED: Тип не определен.
 * - PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS: Успешно.
 * - PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND: Счет не найден или недостаточно прав.
 * - PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR: Произошла ошибка.
 */
export const zV1PortfolioSubscriptionStatus = z
    .enum([
        'PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED',
        'PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS',
        'PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND',
        'PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR',
    ])
    .register(z.globalRegistry, {
        description:
            'Результат подписки.\n\n - PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED: Тип не определен.\n - PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS: Успешно.\n - PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND: Счет не найден или недостаточно прав.\n - PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR: Произошла ошибка.',
    });

/**
 * Счет клиента.
 */
export const zV1AccountSubscriptionStatus = z
    .object({
        accountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счета.',
            }),
        ),
        subscriptionStatus: z.optional(zV1PortfolioSubscriptionStatus),
    })
    .register(z.globalRegistry, {
        description: 'Счет клиента.',
    });

/**
 * Объект результата подписки.
 */
export const zV1PortfolioSubscriptionResult = z
    .object({
        accounts: z.optional(
            z.array(zV1AccountSubscriptionStatus).register(z.globalRegistry, {
                description: 'Массив счетов клиента.',
            }),
        ),
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Уникальный идентификатор запроса, подробнее: [tracking_id](/invest/intro/developer/protocols/grpc#tracking-id).',
            }),
        ),
        streamId: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Объект результата подписки.',
    });

/**
 * Результат подписки.
 *
 * - POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED: Тип не определен.
 * - POSITIONS_SUBSCRIPTION_STATUS_SUCCESS: Успешно.
 * - POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND: Счет не найден или недостаточно прав.
 * - POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR: Произошла ошибка.
 */
export const zV1PositionsAccountSubscriptionStatus = z
    .enum([
        'POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED',
        'POSITIONS_SUBSCRIPTION_STATUS_SUCCESS',
        'POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND',
        'POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR',
    ])
    .register(z.globalRegistry, {
        description:
            'Результат подписки.\n\n - POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED: Тип не определен.\n - POSITIONS_SUBSCRIPTION_STATUS_SUCCESS: Успешно.\n - POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND: Счет не найден или недостаточно прав.\n - POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR: Произошла ошибка.',
    });

/**
 * Баланс фьючерса.
 */
export const zV1PositionsFutures = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор фьючерса.',
            }),
        ),
        blocked: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество бумаг, заблокированных выставленными заявками.',
            }),
        ),
        balance: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Текущий незаблокированный баланс.',
            }),
        ),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор  инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Баланс фьючерса.',
    });

/**
 * Валютная позиция портфеля.
 */
export const zV1PositionsMoney = z
    .object({
        availableValue: z.optional(zV1MoneyValue),
        blockedValue: z.optional(zV1MoneyValue),
    })
    .register(z.globalRegistry, {
        description: 'Валютная позиция портфеля.',
    });

/**
 * Баланс опциона.
 */
export const zV1PositionsOptions = z
    .object({
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции опциона.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор  инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        blocked: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество бумаг, заблокированных выставленными заявками.',
            }),
        ),
        balance: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Текущий незаблокированный баланс.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Баланс опциона.',
    });

/**
 * Запрос позиций портфеля по счету.
 */
export const zV1PositionsRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета пользователя.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос позиций портфеля по счету.',
    });

/**
 * Баланс позиции ценной бумаги.
 */
export const zV1PositionsSecurities = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор бумаги.',
            }),
        ),
        blocked: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество бумаг, заблокированных выставленными заявками.',
            }),
        ),
        balance: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Текущий незаблокированный баланс.',
            }),
        ),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        exchangeBlocked: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Заблокировано на бирже.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Баланс позиции ценной бумаги.',
    });

/**
 * Данные о позиции портфеля.
 */
export const zV1PositionData = z
    .object({
        accountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счета.',
            }),
        ),
        money: z.optional(
            z.array(zV1PositionsMoney).register(z.globalRegistry, {
                description: 'Массив валютных позиций портфеля.',
            }),
        ),
        securities: z.optional(
            z.array(zV1PositionsSecurities).register(z.globalRegistry, {
                description: 'Список ценно-бумажных позиций портфеля.',
            }),
        ),
        futures: z.optional(
            z.array(zV1PositionsFutures).register(z.globalRegistry, {
                description: 'Список фьючерсов портфеля.',
            }),
        ),
        options: z.optional(
            z.array(zV1PositionsOptions).register(z.globalRegistry, {
                description: 'Список опционов портфеля.',
            }),
        ),
        date: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время операции в формате UTC.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные о позиции портфеля.',
    });

/**
 * Список позиций по счету.
 */
export const zV1PositionsResponse = z
    .object({
        money: z.optional(
            z.array(zV1MoneyValue).register(z.globalRegistry, {
                description: 'Массив валютных позиций портфеля.',
            }),
        ),
        blocked: z.optional(
            z.array(zV1MoneyValue).register(z.globalRegistry, {
                description: 'Массив заблокированных валютных позиций портфеля.',
            }),
        ),
        securities: z.optional(
            z.array(zV1PositionsSecurities).register(z.globalRegistry, {
                description: 'Список ценно-бумажных позиций портфеля.',
            }),
        ),
        limitsLoadingInProgress: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак идущей выгрузки лимитов в данный момент.',
            }),
        ),
        futures: z.optional(
            z.array(zV1PositionsFutures).register(z.globalRegistry, {
                description: 'Список фьючерсов портфеля.',
            }),
        ),
        options: z.optional(
            z.array(zV1PositionsOptions).register(z.globalRegistry, {
                description: 'Список опционов портфеля.',
            }),
        ),
        accountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счёта пользователя.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список позиций по счету.',
    });

/**
 * Запрос установки stream-соединения позиций.
 */
export const zV1PositionsStreamRequest = z
    .object({
        accounts: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description: 'Массив идентификаторов счетов пользователя.',
            }),
        ),
        withInitialPositions: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Получение состояния позиций на момент подключения.',
            }),
        ),
        pingSettings: z.optional(zV1PingDelaySettings),
    })
    .register(z.globalRegistry, {
        description: 'Запрос установки stream-соединения позиций.',
    });

/**
 * Счет клиента.
 */
export const zV1PositionsSubscriptionStatus = z
    .object({
        accountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счета.',
            }),
        ),
        subscriptionStatus: z.optional(zV1PositionsAccountSubscriptionStatus),
    })
    .register(z.globalRegistry, {
        description: 'Счет клиента.',
    });

/**
 * Объект результата подписки.
 */
export const zV1PositionsSubscriptionResult = z
    .object({
        accounts: z.optional(
            z.array(zV1PositionsSubscriptionStatus).register(z.globalRegistry, {
                description: 'Массив счетов клиента.',
            }),
        ),
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Уникальный идентификатор запроса, подробнее: [tracking_id](/invest/intro/developer/protocols/grpc#tracking-id).',
            }),
        ),
        streamId: z.optional(z.string()),
    })
    .register(z.globalRegistry, {
        description: 'Объект результата подписки.',
    });

/**
 * Информация по изменению позиций портфеля.
 */
export const zV1PositionsStreamResponse = z
    .object({
        subscriptions: z.optional(zV1PositionsSubscriptionResult),
        position: z.optional(zV1PositionData),
        ping: z.optional(zV1Ping),
        initialPositions: z.optional(zV1PositionsResponse),
    })
    .register(z.globalRegistry, {
        description: 'Информация по изменению позиций портфеля.',
    });

/**
 * Результат выставления асинхронного торгового поручения.
 */
export const zV1PostOrderAsyncResponse = z
    .object({
        orderRequestId: z.string().register(z.globalRegistry, {
            description:
                'Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов.',
        }),
        executionReportStatus: zV1OrderExecutionReportStatus,
        tradeIntentId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор торгового поручения.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат выставления асинхронного торгового поручения.',
    });

/**
 * Тип цены.
 *
 * - PRICE_TYPE_UNSPECIFIED: Значение не определено.
 * - PRICE_TYPE_POINT: Цена в пунктах (только для фьючерсов и облигаций).
 * - PRICE_TYPE_CURRENCY: Цена в валюте расчетов по инструменту.
 */
export const zV1PriceType = z
    .enum(['PRICE_TYPE_UNSPECIFIED', 'PRICE_TYPE_POINT', 'PRICE_TYPE_CURRENCY'])
    .register(z.globalRegistry, {
        description:
            'Тип цены.\n\n - PRICE_TYPE_UNSPECIFIED: Значение не определено.\n - PRICE_TYPE_POINT: Цена в пунктах (только для фьючерсов и облигаций).\n - PRICE_TYPE_CURRENCY: Цена в валюте расчетов по инструменту.',
    });

/**
 * Запрос получения статуса торгового поручения.
 */
export const zV1GetOrderStateRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        orderId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор заявки.',
        }),
        priceType: z.optional(zV1PriceType),
        orderIdType: z.optional(zV1OrderIdType),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения статуса торгового поручения.',
    });

/**
 * Котировка — денежная сумма без указания валюты.
 */
export const zV1Quotation = z
    .object({
        units: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Целая часть суммы, может быть отрицательным числом.',
            }),
        ),
        nano: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Дробная часть суммы, может быть отрицательным числом.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Котировка — денежная сумма без указания валюты.',
    });

export const zGetBondEventsResponseBondEvent = z.object({
    instrumentId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента.',
        }),
    ),
    eventNumber: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Номер события для данного типа события.',
        }),
    ),
    eventDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата события.',
        }),
    ),
    eventType: z.optional(zGetBondEventsRequestEventType),
    eventTotalVol: z.optional(zV1Quotation),
    fixDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата фиксации владельцев для участия в событии.',
        }),
    ),
    rateDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата определения даты или факта события.',
        }),
    ),
    defaultDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата дефолта, если применимо.',
        }),
    ),
    realPayDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата реального исполнения обязательства.',
        }),
    ),
    payDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата выплаты.',
        }),
    ),
    payOneBond: z.optional(zV1MoneyValue),
    moneyFlowVal: z.optional(zV1MoneyValue),
    execution: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Признак исполнения.',
        }),
    ),
    operationType: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тип операции.',
        }),
    ),
    value: z.optional(zV1Quotation),
    note: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Примечание.',
        }),
    ),
    convertToFinToolId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'ID выпуска бумаг, в который произведена конвертация (для конвертаций).',
        }),
    ),
    couponStartDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало купонного периода.',
        }),
    ),
    couponEndDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Окончание купонного периода.',
        }),
    ),
    couponPeriod: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Купонный период.',
        }),
    ),
    couponInterestRate: z.optional(zV1Quotation),
});

export const zGetInsiderDealsResponseInsiderDeal = z.object({
    tradeId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор сделки.',
        }),
    ),
    direction: z.optional(zV1GetInsiderDealsResponseTradeDirection),
    currency: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Валюта сделки.',
        }),
    ),
    date: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата сделки.',
        }),
    ),
    quantity: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Количество.',
        }),
    ),
    price: z.optional(zV1Quotation),
    instrumentUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор инструмента.',
        }),
    ),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    investorName: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Имя инвестора.',
        }),
    ),
    investorPosition: z.optional(z.string()),
    percentage: z.optional(z.number()),
    isOptionExecution: z.optional(z.boolean()),
    disclosureDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата раскрытия сделки.',
        }),
    ),
});

export const zGetMaxLotsResponseBuyLimitsView = z.object({
    buyMoneyAmount: z.optional(zV1Quotation),
    buyMaxLots: z.optional(z.string()),
    buyMaxMarketLots: z.optional(z.string()),
});

export const zGetOrderPriceResponseExtraBond = z.object({
    aciValue: z.optional(zV1MoneyValue),
    nominalConversionRate: z.optional(zV1Quotation),
});

export const zGetTechAnalysisRequestDeviation = z.object({
    deviationMultiplier: z.optional(zV1Quotation),
});

export const zGetTechAnalysisResponseTechAnalysisItem = z.object({
    timestamp: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Временная метка по UTC, для которой были рассчитаны значения индикатора.',
        }),
    ),
    middleBand: z.optional(zV1Quotation),
    upperBand: z.optional(zV1Quotation),
    lowerBand: z.optional(zV1Quotation),
    signal: z.optional(zV1Quotation),
    macd: z.optional(zV1Quotation),
});

export const zRiskRatesResponseRiskRate = z.object({
    riskLevelCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Категория риска.',
        }),
    ),
    value: z.optional(zV1Quotation),
});

export const zRiskRatesResponseRiskRateResult = z.object({
    instrumentUid: z.optional(z.string()),
    shortRiskRate: z.optional(zRiskRatesResponseRiskRate),
    longRiskRate: z.optional(zRiskRatesResponseRiskRate),
    shortRiskRates: z.optional(z.array(zRiskRatesResponseRiskRate)),
    longRiskRates: z.optional(z.array(zRiskRatesResponseRiskRate)),
    error: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Ошибка.',
        }),
    ),
});

/**
 * Базовый актив.
 */
export const zStructuredNoteBasicAsset = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор базового актива.',
            }),
        ),
        type: z.optional(zV1AssetType),
        initialPrice: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Базовый актив.',
    });

/**
 * Доходность.
 */
export const zStructuredNoteYield = z
    .object({
        type: z.optional(zStructuredNoteYieldType),
        value: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Доходность.',
    });

/**
 * Операция начисления купонов.
 */
export const zV1AccruedInterest = z
    .object({
        date: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время выплаты по UTC.',
            }),
        ),
        value: z.optional(zV1Quotation),
        valuePercent: z.optional(zV1Quotation),
        nominal: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Операция начисления купонов.',
    });

/**
 * Облигация.
 */
export const zV1AssetBond = z
    .object({
        currentNominal: z.optional(zV1Quotation),
        borrowName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование заемщика.',
            }),
        ),
        issueSize: z.optional(zV1Quotation),
        nominal: z.optional(zV1Quotation),
        nominalCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта номинала.',
            }),
        ),
        issueKind: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Форма выпуска облигации.',
            }),
        ),
        interestKind: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Форма дохода облигации.',
            }),
        ),
        couponQuantityPerYear: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Количество выплат в год.',
            }),
        ),
        indexedNominalFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак облигации с индексируемым номиналом.',
            }),
        ),
        subordinatedFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак субординированной облигации.',
            }),
        ),
        collateralFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак обеспеченной облигации.',
            }),
        ),
        taxFreeFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Признак показывает, что купоны облигации не облагаются налогом — для mass market.',
            }),
        ),
        amortizationFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак облигации с амортизацией долга.',
            }),
        ),
        floatingCouponFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак облигации с плавающим купоном.',
            }),
        ),
        perpetualFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак бессрочной облигации.',
            }),
        ),
        maturityDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата погашения облигации.',
            }),
        ),
        returnCondition: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Описание и условия получения дополнительного дохода.',
            }),
        ),
        stateRegDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата выпуска облигации.',
            }),
        ),
        placementDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата размещения облигации.',
            }),
        ),
        placementPrice: z.optional(zV1Quotation),
        issueSizePlan: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Облигация.',
    });

/**
 * Клиринговый сертификат участия.
 */
export const zV1AssetClearingCertificate = z
    .object({
        nominal: z.optional(zV1Quotation),
        nominalCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта номинала.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Клиринговый сертификат участия.',
    });

/**
 * Фонд.
 */
export const zV1AssetEtf = z
    .object({
        totalExpense: z.optional(zV1Quotation),
        hurdleRate: z.optional(zV1Quotation),
        performanceFee: z.optional(zV1Quotation),
        fixedCommission: z.optional(zV1Quotation),
        paymentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип распределения доходов от выплат по бумагам.',
            }),
        ),
        watermarkFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак необходимости выхода фонда в плюс для получения комиссии.',
            }),
        ),
        buyPremium: z.optional(zV1Quotation),
        sellDiscount: z.optional(zV1Quotation),
        rebalancingFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак ребалансируемости портфеля фонда.',
            }),
        ),
        rebalancingFreq: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Периодичность ребалансировки.',
            }),
        ),
        managementType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип управления.',
            }),
        ),
        primaryIndex: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Индекс, который реплицирует (старается копировать) фонд.',
            }),
        ),
        focusType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'База ETF.',
            }),
        ),
        leveragedFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак использования заемных активов (плечо).',
            }),
        ),
        numShare: z.optional(zV1Quotation),
        ucitsFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак обязательства по отчетности перед регулятором.',
            }),
        ),
        releasedDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата выпуска.',
            }),
        ),
        description: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Описание фонда.',
            }),
        ),
        primaryIndexDescription: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Описание индекса, за которым следует фонд.',
            }),
        ),
        primaryIndexCompany: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Основные компании, в которые вкладывается фонд.',
            }),
        ),
        indexRecoveryPeriod: z.optional(zV1Quotation),
        inavCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'IVAV-код.',
            }),
        ),
        divYieldFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак наличия дивидендной доходности.',
            }),
        ),
        expenseCommission: z.optional(zV1Quotation),
        primaryIndexTrackingError: z.optional(zV1Quotation),
        rebalancingPlan: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Плановая ребалансировка портфеля.',
            }),
        ),
        taxRate: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Ставки налогообложения дивидендов и купонов.',
            }),
        ),
        rebalancingDates: z.optional(
            z.array(z.iso.datetime()).register(z.globalRegistry, {
                description: 'Даты ребалансировок.',
            }),
        ),
        issueKind: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Форма выпуска.',
            }),
        ),
        nominal: z.optional(zV1Quotation),
        nominalCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта номинала.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Фонд.',
    });

export const zV1BrokerReport = z.object({
    tradeId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Номер сделки.',
        }),
    ),
    orderId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Номер поручения.',
        }),
    ),
    figi: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'FIGI-идентификаторинструмента.',
        }),
    ),
    executeSign: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Признак исполнения.',
        }),
    ),
    tradeDatetime: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время заключения по UTC.',
        }),
    ),
    exchange: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Торговая площадка.',
        }),
    ),
    classCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Режим торгов.',
        }),
    ),
    direction: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Вид сделки.',
        }),
    ),
    name: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Сокращенное наименование актива.',
        }),
    ),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код актива.',
        }),
    ),
    price: z.optional(zV1MoneyValue),
    quantity: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Количество.',
        }),
    ),
    orderAmount: z.optional(zV1MoneyValue),
    aciValue: z.optional(zV1Quotation),
    totalOrderAmount: z.optional(zV1MoneyValue),
    brokerCommission: z.optional(zV1MoneyValue),
    exchangeCommission: z.optional(zV1MoneyValue),
    exchangeClearingCommission: z.optional(zV1MoneyValue),
    repoRate: z.optional(zV1Quotation),
    party: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Контрагент или брокерарокер.',
        }),
    ),
    clearValueDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата расчетов по UTC.',
        }),
    ),
    secValueDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата поставки по UTC.',
        }),
    ),
    brokerStatus: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Статус брокера.',
        }),
    ),
    separateAgreementType: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тип договора.',
        }),
    ),
    separateAgreementNumber: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Номер договора.',
        }),
    ),
    separateAgreementDate: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Дата договора.',
        }),
    ),
    deliveryType: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тип расчета по сделке.',
        }),
    ),
});

/**
 * Информация о выплате.
 */
export const zV1Dividend = z
    .object({
        dividendNet: z.optional(zV1MoneyValue),
        paymentDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата фактических выплат по UTC.',
            }),
        ),
        declaredDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата объявления дивидендов по UTC.',
            }),
        ),
        lastBuyDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Последний день (включительно) покупки для получения выплаты по UTC.',
            }),
        ),
        dividendType: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Тип выплаты. Возможные значения: `Regular Cash` – регулярные выплаты, `Cancelled` – выплата отменена, `Daily Accrual` – ежедневное начисление, `Return of Capital` – возврат капитала, прочие типы выплат.',
            }),
        ),
        recordDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата фиксации реестра по UTC.',
            }),
        ),
        regularity: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Регулярность выплаты. Возможные значения: `Annual` – ежегодная, `Semi-Anl` – каждые полгода, прочие типы выплат.',
            }),
        ),
        closePrice: z.optional(zV1MoneyValue),
        yieldValue: z.optional(zV1Quotation),
        createdAt: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время создания записи по UTC.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о выплате.',
    });

/**
 * Отчет «Справка о доходах за пределами РФ».
 */
export const zV1DividendsForeignIssuerReport = z
    .object({
        recordDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата фиксации реестра.',
            }),
        ),
        paymentDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата выплаты.',
            }),
        ),
        securityName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование ценной бумаги.',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор ценной бумаги.',
            }),
        ),
        issuerCountry: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Страна эмитента. Для депозитарных расписок указывается страна эмитента базового актива.',
            }),
        ),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество ценных бумаг.',
            }),
        ),
        dividend: z.optional(zV1Quotation),
        externalCommission: z.optional(zV1Quotation),
        dividendGross: z.optional(zV1Quotation),
        tax: z.optional(zV1Quotation),
        dividendAmount: z.optional(zV1Quotation),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Отчет «Справка о доходах за пределами РФ».',
    });

/**
 * НКД облигации.
 */
export const zV1GetAccruedInterestsResponse = z
    .object({
        accruedInterests: z.optional(
            z.array(zV1AccruedInterest).register(z.globalRegistry, {
                description: 'Массив операций начисления купонов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'НКД облигации.',
    });

/**
 * Объект передачи информации о событии облигации.
 */
export const zV1GetBondEventsResponse = z
    .object({
        events: z.optional(z.array(zGetBondEventsResponseBondEvent)),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации о событии облигации.',
    });

export const zV1GetBrokerReportResponse = z.object({
    brokerReport: z.optional(z.array(zV1BrokerReport)),
    itemsCount: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество записей в отчете.',
        }),
    ),
    pagesCount: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество страниц с данными отчета, начинается с 0.',
        }),
    ),
    page: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Текущая страница, начинается с 0.',
        }),
    ),
});

export const zV1BrokerReportResponse = z.object({
    generateBrokerReportResponse: z.optional(zV1GenerateBrokerReportResponse),
    getBrokerReportResponse: z.optional(zV1GetBrokerReportResponse),
});

export const zV1GetDividendsForeignIssuerReportResponse = z.object({
    dividendsForeignIssuerReport: z.optional(z.array(zV1DividendsForeignIssuerReport)),
    itemsCount: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество записей в отчете.',
        }),
    ),
    pagesCount: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество страниц с данными отчета, начинается с 0.',
        }),
    ),
    page: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Текущая страница, начинается с 0.',
        }),
    ),
});

export const zV1GetDividendsForeignIssuerResponse = z.object({
    generateDivForeignIssuerReportResponse: z.optional(
        zV1GenerateDividendsForeignIssuerReportResponse,
    ),
    divForeignIssuerReport: z.optional(zV1GetDividendsForeignIssuerReportResponse),
});

/**
 * Дивиденды.
 */
export const zV1GetDividendsResponse = z
    .object({
        dividends: z.optional(z.array(zV1Dividend)),
    })
    .register(z.globalRegistry, {
        description: 'Дивиденды.',
    });

/**
 * Данные по фьючерсу
 */
export const zV1GetFuturesMarginResponse = z.object({
    initialMarginOnBuy: z.optional(zV1MoneyValue),
    initialMarginOnSell: z.optional(zV1MoneyValue),
    minPriceIncrement: z.optional(zV1Quotation),
    minPriceIncrementAmount: z.optional(zV1Quotation),
});

/**
 * сделки инсайдеров
 */
export const zV1GetInsiderDealsResponse = z.object({
    insiderDeals: z.optional(
        z.array(zGetInsiderDealsResponseInsiderDeal).register(z.globalRegistry, {
            description: 'Массив сделок.',
        }),
    ),
    nextCursor: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Курсор для получения следующей страницы.',
        }),
    ),
});

/**
 * Маржинальные показатели по счeту.
 */
export const zV1GetMarginAttributesResponse = z
    .object({
        liquidPortfolio: z.optional(zV1MoneyValue),
        startingMargin: z.optional(zV1MoneyValue),
        minimalMargin: z.optional(zV1MoneyValue),
        fundsSufficiencyLevel: z.optional(zV1Quotation),
        amountOfMissingFunds: z.optional(zV1MoneyValue),
        correctedMargin: z.optional(zV1MoneyValue),
    })
    .register(z.globalRegistry, {
        description: 'Маржинальные показатели по счeту.',
    });

/**
 * Запрос на расчет количества доступных для покупки/продажи лотов. Если не указывать цену инструмента, то расчет произведется по текущум ценам в стакане: по лучшему предложению для покупки и по лучшему спросу для продажи.
 */
export const zV1GetMaxLotsRequest = z
    .object({
        accountId: z.string(),
        instrumentId: z.string(),
        price: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description:
            'Запрос на расчет количества доступных для покупки/продажи лотов. Если не указывать цену инструмента, то расчет произведется по текущум ценам в стакане: по лучшему предложению для покупки и по лучшему спросу для продажи.',
    });

/**
 * Результат количество доступных для покупки/продажи лотов
 */
export const zV1GetMaxLotsResponse = z.object({
    currency: z.optional(z.string()),
    buyLimits: z.optional(zGetMaxLotsResponseBuyLimitsView),
    buyMarginLimits: z.optional(zGetMaxLotsResponseBuyLimitsView),
    sellLimits: z.optional(zGetMaxLotsResponseSellLimitsView),
    sellMarginLimits: z.optional(zGetMaxLotsResponseSellLimitsView),
});

/**
 * Запрос получения предварительной стоимости заявки
 */
export const zV1GetOrderPriceRequest = z.object({
    accountId: z.optional(z.string()),
    instrumentId: z.optional(z.string()),
    price: z.optional(zV1Quotation),
    direction: z.optional(zV1OrderDirection),
    quantity: z.optional(z.string()),
});

/**
 * Предварительная стоимость заявки
 */
export const zV1GetOrderPriceResponse = z.object({
    totalOrderAmount: z.optional(zV1MoneyValue),
    initialOrderAmount: z.optional(zV1MoneyValue),
    lotsRequested: z.optional(z.string()),
    executedCommission: z.optional(zV1MoneyValue),
    executedCommissionRub: z.optional(zV1MoneyValue),
    serviceCommission: z.optional(zV1MoneyValue),
    dealCommission: z.optional(zV1MoneyValue),
    extraBond: z.optional(zGetOrderPriceResponseExtraBond),
    extraFuture: z.optional(zGetOrderPriceResponseExtraFuture),
});

export const zV1GetTechAnalysisRequest = z.object({
    indicatorType: zGetTechAnalysisRequestIndicatorType,
    instrumentUid: z.string().register(z.globalRegistry, {
        description: 'UID инструмента.',
    }),
    from: z.iso.datetime().register(z.globalRegistry, {
        description: 'Начало запрашиваемого периода по UTC.',
    }),
    to: z.iso.datetime().register(z.globalRegistry, {
        description: 'Окончание запрашиваемого периода по UTC.',
    }),
    interval: zGetTechAnalysisRequestIndicatorInterval,
    typeOfPrice: zGetTechAnalysisRequestTypeOfPrice,
    length: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Торговый период, за который рассчитывается индикатор.',
        }),
    ),
    deviation: z.optional(zGetTechAnalysisRequestDeviation),
    smoothing: z.optional(zGetTechAnalysisRequestSmoothing),
});

export const zV1GetTechAnalysisResponse = z.object({
    technicalIndicators: z.optional(
        z.array(zGetTechAnalysisResponseTechAnalysisItem).register(z.globalRegistry, {
            description: 'Массив значений результатов технического анализа.',
        }),
    ),
});

/**
 * Информация о свече.
 */
export const zV1HistoricCandle = z
    .object({
        open: z.optional(zV1Quotation),
        high: z.optional(zV1Quotation),
        low: z.optional(zV1Quotation),
        close: z.optional(zV1Quotation),
        volume: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Объем торгов в лотах.',
            }),
        ),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время свечи в часовом поясе UTC.',
            }),
        ),
        isComplete: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Признак завершенности свечи. **false** — свеча за текущие интервал еще сформирована не полностью.',
            }),
        ),
        candleSource: z.optional(zContractv1CandleSource),
        volumeBuy: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Объем торгов на покупку.',
            }),
        ),
        volumeSell: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Объём торгов на продажу.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о свече.',
    });

/**
 * Список свечей.
 */
export const zV1GetCandlesResponse = z
    .object({
        candles: z.optional(
            z.array(zV1HistoricCandle).register(z.globalRegistry, {
                description: 'Массив свечей.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список свечей.',
    });

/**
 * Цена закрытия торговой сессии по инструменту.
 */
export const zV1InstrumentClosePriceResponse = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI инструмента.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        price: z.optional(zV1Quotation),
        eveningSessionPrice: z.optional(zV1Quotation),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата совершения торгов.',
            }),
        ),
        eveningSessionPriceTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата цены закрытия вечерней сессии.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Цена закрытия торговой сессии по инструменту.',
    });

/**
 * Цены закрытия торговой сессии по инструментам.
 */
export const zV1GetClosePricesResponse = z
    .object({
        closePrices: z.optional(
            z.array(zV1InstrumentClosePriceResponse).register(z.globalRegistry, {
                description: 'Массив по инструментам.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Цены закрытия торговой сессии по инструментам.',
    });

/**
 * Информация о цене последней сделки.
 */
export const zV1LastPrice = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI инструмента.',
            }),
        ),
        price: z.optional(zV1Quotation),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время получения последней цены в часовом поясе UTC по времени биржи.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        lastPriceType: z.optional(zV1LastPriceType),
    })
    .register(z.globalRegistry, {
        description: 'Информация о цене последней сделки.',
    });

/**
 * Список цен последних сделок.
 */
export const zV1GetLastPricesResponse = z
    .object({
        lastPrices: z.optional(
            z.array(zV1LastPrice).register(z.globalRegistry, {
                description: 'Массив цен последних сделок.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список цен последних сделок.',
    });

export const zV1MarketValue = z.object({
    type: z.optional(zV1MarketValueType),
    value: z.optional(zV1Quotation),
    time: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время.',
        }),
    ),
});

export const zV1MarketValueInstrument = z.object({
    instrumentUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента.',
        }),
    ),
    values: z.optional(
        z.array(zV1MarketValue).register(z.globalRegistry, {
            description: 'Массив параметров инструмента.',
        }),
    ),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    classCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Класс-код (секция торгов).',
        }),
    ),
});

export const zV1GetMarketValuesResponse = z.object({
    instruments: z.optional(
        z.array(zV1MarketValueInstrument).register(z.globalRegistry, {
            description: 'Массив значений параметров.',
        }),
    ),
});

/**
 * Сделка по операции.
 */
export const zV1OperationItemTrade = z
    .object({
        num: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Номер сделки.',
            }),
        ),
        date: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата сделки.',
            }),
        ),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество в единицах.',
            }),
        ),
        price: z.optional(zV1MoneyValue),
        yield: z.optional(zV1MoneyValue),
        yieldRelative: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Сделка по операции.',
    });

/**
 * Массив с информацией о сделках.
 */
export const zV1OperationItemTrades = z
    .object({
        trades: z.optional(z.array(zV1OperationItemTrade)),
    })
    .register(z.globalRegistry, {
        description: 'Массив с информацией о сделках.',
    });

/**
 * Данные об операции.
 */
export const zV1OperationItem = z
    .object({
        cursor: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Курсор.',
            }),
        ),
        brokerAccountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Номер счета клиента.',
            }),
        ),
        id: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор операции, может меняться с течением времени.',
            }),
        ),
        parentOperationId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Идентификатор родительской операции. Может измениться, если изменился ID родительской операции.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название операции.',
            }),
        ),
        date: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата поручения.',
            }),
        ),
        type: z.optional(zV1OperationType),
        description: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Описание операции.',
            }),
        ),
        state: z.optional(zV1OperationState),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
        instrumentKind: z.optional(zV1InstrumentType),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        payment: z.optional(zV1MoneyValue),
        price: z.optional(zV1MoneyValue),
        commission: z.optional(zV1MoneyValue),
        yield: z.optional(zV1MoneyValue),
        yieldRelative: z.optional(zV1Quotation),
        accruedInt: z.optional(zV1MoneyValue),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество единиц инструмента.',
            }),
        ),
        quantityRest: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Неисполненный остаток по сделке.',
            }),
        ),
        quantityDone: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Исполненный остаток.',
            }),
        ),
        cancelDateTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время снятия заявки.',
            }),
        ),
        cancelReason: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Причина отмены операции.',
            }),
        ),
        tradesInfo: z.optional(zV1OperationItemTrades),
        assetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор актива.',
            }),
        ),
        childOperations: z.optional(
            z.array(zV1ChildOperationItem).register(z.globalRegistry, {
                description: 'Массив дочерних операций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные об операции.',
    });

/**
 * Список операций по счету с пагинацией.
 */
export const zV1GetOperationsByCursorResponse = z
    .object({
        hasNext: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак, есть ли следующий элемент.',
            }),
        ),
        nextCursor: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Следующий курсор.',
            }),
        ),
        items: z.optional(
            z.array(zV1OperationItem).register(z.globalRegistry, {
                description: 'Список операций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список операций по счету с пагинацией.',
    });

/**
 * Массив предложений/спроса.
 */
export const zV1Order = z
    .object({
        price: z.optional(zV1Quotation),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество в лотах.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Массив предложений/спроса.',
    });

/**
 * Информация о стакане.
 */
export const zV1GetOrderBookResponse = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        depth: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Глубина стакана.',
            }),
        ),
        bids: z.optional(
            z.array(zV1Order).register(z.globalRegistry, {
                description: 'Множество пар значений на покупку.',
            }),
        ),
        asks: z.optional(
            z.array(zV1Order).register(z.globalRegistry, {
                description: 'Множество пар значений на продажу.',
            }),
        ),
        lastPrice: z.optional(zV1Quotation),
        closePrice: z.optional(zV1Quotation),
        limitUp: z.optional(zV1Quotation),
        limitDown: z.optional(zV1Quotation),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        lastPriceTs: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время получения цены последней сделки.',
            }),
        ),
        closePriceTs: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время получения цены закрытия.',
            }),
        ),
        orderbookTs: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время формирования стакана на бирже.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о стакане.',
    });

/**
 * Пакет стаканов в рамках стрима.
 */
export const zV1OrderBook = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        depth: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Глубина стакана.',
            }),
        ),
        isConsistent: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг консистентности стакана. **false** — не все заявки попали в стакан из-за сетевых задержек или нарушения порядка доставки.',
            }),
        ),
        bids: z.optional(
            z.array(zV1Order).register(z.globalRegistry, {
                description: 'Массив предложений.',
            }),
        ),
        asks: z.optional(
            z.array(zV1Order).register(z.globalRegistry, {
                description: 'Массив спроса.',
            }),
        ),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время формирования стакана в часовом поясе UTC по времени биржи.',
            }),
        ),
        limitUp: z.optional(zV1Quotation),
        limitDown: z.optional(zV1Quotation),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        orderBookType: z.optional(zV1OrderBookType),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Пакет стаканов в рамках стрима.',
    });

/**
 * Информация о сделке.
 */
export const zV1OrderTrade = z
    .object({
        dateTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время совершения сделки в часовом поясе UTC.',
            }),
        ),
        price: z.optional(zV1Quotation),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество штук в сделке.',
            }),
        ),
        tradeId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор сделки.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о сделке.',
    });

/**
 * Информация об исполнении торгового поручения.
 */
export const zV1OrderTrades = z
    .object({
        orderId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор торгового поручения.',
            }),
        ),
        createdAt: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время создания сообщения в часовом поясе UTC.',
            }),
        ),
        direction: z.optional(zV1OrderDirection),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Figi-идентификатор инструмента.',
            }),
        ),
        trades: z.optional(
            z.array(zV1OrderTrade).register(z.globalRegistry, {
                description: 'Массив сделок.',
            }),
        ),
        accountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счета.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID идентификатор инструмента.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация об исполнении торгового поручения.',
    });

/**
 * Позиции портфеля.
 */
export const zV1PortfolioPosition = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
        quantity: z.optional(zV1Quotation),
        averagePositionPrice: z.optional(zV1MoneyValue),
        expectedYield: z.optional(zV1Quotation),
        currentNkd: z.optional(zV1MoneyValue),
        averagePositionPricePt: z.optional(zV1Quotation),
        currentPrice: z.optional(zV1MoneyValue),
        averagePositionPriceFifo: z.optional(zV1MoneyValue),
        quantityLots: z.optional(zV1Quotation),
        blocked: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Заблокировано на бирже.',
            }),
        ),
        blockedLots: z.optional(zV1Quotation),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        varMargin: z.optional(zV1MoneyValue),
        expectedYieldFifo: z.optional(zV1Quotation),
        dailyYield: z.optional(zV1MoneyValue),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Позиции портфеля.',
    });

/**
 * Реальная площадка исполнения расчетов.
 *
 * - REAL_EXCHANGE_UNSPECIFIED: Тип не определен.
 * - REAL_EXCHANGE_MOEX: Московская биржа.
 * - REAL_EXCHANGE_RTS: Санкт-Петербургская биржа.
 * - REAL_EXCHANGE_OTC: Внебиржевой инструмент.
 * - REAL_EXCHANGE_DEALER: Инструмент, торгуемый на площадке брокера.
 */
export const zV1RealExchange = z
    .enum([
        'REAL_EXCHANGE_UNSPECIFIED',
        'REAL_EXCHANGE_MOEX',
        'REAL_EXCHANGE_RTS',
        'REAL_EXCHANGE_OTC',
        'REAL_EXCHANGE_DEALER',
    ])
    .register(z.globalRegistry, {
        description:
            'Реальная площадка исполнения расчетов.\n\n - REAL_EXCHANGE_UNSPECIFIED: Тип не определен.\n - REAL_EXCHANGE_MOEX: Московская биржа.\n - REAL_EXCHANGE_RTS: Санкт-Петербургская биржа.\n - REAL_EXCHANGE_OTC: Внебиржевой инструмент.\n - REAL_EXCHANGE_DEALER: Инструмент, торгуемый на площадке брокера.',
    });

/**
 *  - RECOMMENDATION_UNSPECIFIED: Не определено.
 * - RECOMMENDATION_BUY: Покупать.
 * - RECOMMENDATION_HOLD: Держать.
 * - RECOMMENDATION_SELL: Продавать.
 */
export const zV1Recommendation = z
    .enum([
        'RECOMMENDATION_UNSPECIFIED',
        'RECOMMENDATION_BUY',
        'RECOMMENDATION_HOLD',
        'RECOMMENDATION_SELL',
    ])
    .register(z.globalRegistry, {
        description:
            ' - RECOMMENDATION_UNSPECIFIED: Не определено.\n - RECOMMENDATION_BUY: Покупать.\n - RECOMMENDATION_HOLD: Держать.\n - RECOMMENDATION_SELL: Продавать.',
    });

/**
 * Прогноз
 */
export const zGetConsensusForecastsResponseConsensusForecastsItem = z.object({
    uid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'UID-идентификатор.',
        }),
    ),
    assetUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'UID-идентификатор актива.',
        }),
    ),
    createdAt: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время создания записи.',
        }),
    ),
    bestTargetPrice: z.optional(zV1Quotation),
    bestTargetLow: z.optional(zV1Quotation),
    bestTargetHigh: z.optional(zV1Quotation),
    totalBuyRecommend: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество аналитиков рекомендующих покупать.',
        }),
    ),
    totalHoldRecommend: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество аналитиков рекомендующих держать.',
        }),
    ),
    totalSellRecommend: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Количество аналитиков рекомендующих продавать.',
        }),
    ),
    currency: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Валюта прогнозов инструмента.',
        }),
    ),
    consensus: z.optional(zV1Recommendation),
    prognosisDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата прогноза.',
        }),
    ),
});

/**
 * Консенсус-прогноз.
 */
export const zGetForecastResponseConsensusItem = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        recommendation: z.optional(zV1Recommendation),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта.',
            }),
        ),
        currentPrice: z.optional(zV1Quotation),
        consensus: z.optional(zV1Quotation),
        minTarget: z.optional(zV1Quotation),
        maxTarget: z.optional(zV1Quotation),
        priceChange: z.optional(zV1Quotation),
        priceChangeRel: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Консенсус-прогноз.',
    });

/**
 * Прогноз
 */
export const zGetForecastResponseTargetItem = z.object({
    uid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор инструмента.',
        }),
    ),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    company: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Название компании, давшей прогноз.',
        }),
    ),
    recommendation: z.optional(zV1Recommendation),
    recommendationDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата прогноза.',
        }),
    ),
    currency: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Валюта.',
        }),
    ),
    currentPrice: z.optional(zV1Quotation),
    targetPrice: z.optional(zV1Quotation),
    priceChange: z.optional(zV1Quotation),
    priceChangeRel: z.optional(zV1Quotation),
    showName: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Наименование инструмента.',
        }),
    ),
});

/**
 * Консенсус-прогнозы
 */
export const zV1GetConsensusForecastsResponse = z.object({
    items: z.optional(
        z.array(zGetConsensusForecastsResponseConsensusForecastsItem).register(z.globalRegistry, {
            description: 'Массив прогнозов.',
        }),
    ),
    page: z.optional(zV1PageResponse),
});

/**
 * Прогнозы инвестдомов по инструменту.
 */
export const zV1GetForecastResponse = z
    .object({
        targets: z.optional(
            z.array(zGetForecastResponseTargetItem).register(z.globalRegistry, {
                description: 'Массив прогнозов.',
            }),
        ),
        consensus: z.optional(zGetForecastResponseConsensusItem),
    })
    .register(z.globalRegistry, {
        description: 'Прогнозы инвестдомов по инструменту.',
    });

/**
 * Запрос изменения выставленной заявки.
 */
export const zV1ReplaceOrderRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        orderId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор заявки на бирже.',
        }),
        idempotencyKey: z.string().register(z.globalRegistry, {
            description:
                'Новый идентификатор запроса выставления поручения для целей идемпотентности. Максимальная длина 36 символов. Перезатирает старый ключ.',
        }),
        quantity: z.string().register(z.globalRegistry, {
            description: 'Количество лотов.',
        }),
        price: z.optional(zV1Quotation),
        priceType: z.optional(zV1PriceType),
        confirmMarginTrade: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Согласие на выставление заявки, которая может привести к непокрытой позиции, по умолчанию false.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос изменения выставленной заявки.',
    });

export const zV1ResponseMetadata = z.object({
    trackingId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Идентификатор трекинга.',
        }),
    ),
    serverTime: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Серверное время.',
        }),
    ),
});

/**
 * Результат отмены торгового поручения.
 */
export const zV1CancelOrderResponse = z
    .object({
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время отмены заявки в часовом поясе UTC.',
            }),
        ),
        responseMetadata: z.optional(zV1ResponseMetadata),
    })
    .register(z.globalRegistry, {
        description: 'Результат отмены торгового поручения.',
    });

/**
 * Информация о выставлении поручения.
 */
export const zV1PostOrderResponse = z
    .object({
        orderId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Биржевой идентификатор заявки.',
            }),
        ),
        executionReportStatus: z.optional(zV1OrderExecutionReportStatus),
        lotsRequested: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Запрошено лотов.',
            }),
        ),
        lotsExecuted: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Исполнено лотов.',
            }),
        ),
        initialOrderPrice: z.optional(zV1MoneyValue),
        executedOrderPrice: z.optional(zV1MoneyValue),
        totalOrderAmount: z.optional(zV1MoneyValue),
        initialCommission: z.optional(zV1MoneyValue),
        executedCommission: z.optional(zV1MoneyValue),
        aciValue: z.optional(zV1MoneyValue),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Figi-идентификатор инструмента.',
            }),
        ),
        direction: z.optional(zV1OrderDirection),
        initialSecurityPrice: z.optional(zV1MoneyValue),
        orderType: z.optional(zV1OrderType),
        message: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Дополнительные данные об исполнении заявки.',
            }),
        ),
        initialOrderPricePt: z.optional(zV1Quotation),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        orderRequestId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов.',
            }),
        ),
        responseMetadata: z.optional(zV1ResponseMetadata),
    })
    .register(z.globalRegistry, {
        description: 'Информация о выставлении поручения.',
    });

/**
 * Результат выставления стоп-заявки.
 */
export const zV1PostStopOrderResponse = z
    .object({
        stopOrderId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор стоп-заявки.',
            }),
        ),
        orderRequestId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Идентификатор ключа идемпотентности, переданный клиентом, в формате `UID`. Максимальная длина 36 — символов.',
            }),
        ),
        responseMetadata: z.optional(zV1ResponseMetadata),
    })
    .register(z.globalRegistry, {
        description: 'Результат выставления стоп-заявки.',
    });

/**
 * - RESULT_SUBSCRIPTION_STATUS_UNSPECIFIED: Статус подписки не определен.
 * - RESULT_SUBSCRIPTION_STATUS_OK: Подписка успешно установлена.
 * - RESULT_SUBSCRIPTION_STATUS_ERROR: Ошибка подписки
 */
export const zV1ResultSubscriptionStatus = z.enum([
    'RESULT_SUBSCRIPTION_STATUS_UNSPECIFIED',
    'RESULT_SUBSCRIPTION_STATUS_OK',
    'RESULT_SUBSCRIPTION_STATUS_ERROR',
]);

/**
 * Уровень риска облигации.
 *
 * - RISK_LEVEL_UNSPECIFIED: Не указан.
 * - RISK_LEVEL_LOW: Низкий уровень риска.
 * - RISK_LEVEL_MODERATE: Средний уровень риска.
 * - RISK_LEVEL_HIGH: Высокий уровень риска.
 */
export const zV1RiskLevel = z
    .enum(['RISK_LEVEL_UNSPECIFIED', 'RISK_LEVEL_LOW', 'RISK_LEVEL_MODERATE', 'RISK_LEVEL_HIGH'])
    .register(z.globalRegistry, {
        description:
            'Уровень риска облигации.\n\n - RISK_LEVEL_UNSPECIFIED: Не указан.\n - RISK_LEVEL_LOW: Низкий уровень риска.\n - RISK_LEVEL_MODERATE: Средний уровень риска.\n - RISK_LEVEL_HIGH: Высокий уровень риска.',
    });

/**
 * Запрос ставок риска
 */
export const zV1RiskRatesRequest = z.object({
    instrumentId: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description: 'Идентификаторы инструментов.',
        }),
    ),
});

/**
 * Ставки риска
 */
export const zV1RiskRatesResponse = z.object({
    instrumentRiskRates: z.optional(z.array(zRiskRatesResponseRiskRateResult)),
});

/**
 * Запрос пополнения счета в песочнице.
 */
export const zV1SandboxPayInRequest = z
    .object({
        accountId: z.string(),
        amount: zV1MoneyValue,
    })
    .register(z.globalRegistry, {
        description: 'Запрос пополнения счета в песочнице.',
    });

/**
 * Результат пополнения счета, текущий баланс.
 */
export const zV1SandboxPayInResponse = z
    .object({
        balance: z.optional(zV1MoneyValue),
    })
    .register(z.globalRegistry, {
        description: 'Результат пополнения счета, текущий баланс.',
    });

/**
 * Режим торгов инструмента
 *
 * - SECURITY_TRADING_STATUS_UNSPECIFIED: Торговый статус не определен.
 * - SECURITY_TRADING_STATUS_NOT_AVAILABLE_FOR_TRADING: Недоступен для торгов.
 * - SECURITY_TRADING_STATUS_OPENING_PERIOD: Период открытия торгов.
 * - SECURITY_TRADING_STATUS_CLOSING_PERIOD: Период закрытия торгов.
 * - SECURITY_TRADING_STATUS_BREAK_IN_TRADING: Перерыв в торговле.
 * - SECURITY_TRADING_STATUS_NORMAL_TRADING: Нормальная торговля.
 * - SECURITY_TRADING_STATUS_CLOSING_AUCTION: Аукцион закрытия.
 * - SECURITY_TRADING_STATUS_DARK_POOL_AUCTION: Аукцион крупных пакетов.
 * - SECURITY_TRADING_STATUS_DISCRETE_AUCTION: Дискретный аукцион.
 * - SECURITY_TRADING_STATUS_OPENING_AUCTION_PERIOD: Аукцион открытия.
 * - SECURITY_TRADING_STATUS_TRADING_AT_CLOSING_AUCTION_PRICE: Период торгов по цене аукциона закрытия.
 * - SECURITY_TRADING_STATUS_SESSION_ASSIGNED: Сессия назначена.
 * - SECURITY_TRADING_STATUS_SESSION_CLOSE: Сессия закрыта.
 * - SECURITY_TRADING_STATUS_SESSION_OPEN: Сессия открыта.
 * - SECURITY_TRADING_STATUS_DEALER_NORMAL_TRADING: Доступна торговля в режиме внутренней ликвидности брокера.
 * - SECURITY_TRADING_STATUS_DEALER_BREAK_IN_TRADING: Перерыв торговли в режиме внутренней ликвидности брокера.
 * - SECURITY_TRADING_STATUS_DEALER_NOT_AVAILABLE_FOR_TRADING: Недоступна торговля в режиме внутренней ликвидности брокера.
 */
export const zV1SecurityTradingStatus = z
    .enum([
        'SECURITY_TRADING_STATUS_UNSPECIFIED',
        'SECURITY_TRADING_STATUS_NOT_AVAILABLE_FOR_TRADING',
        'SECURITY_TRADING_STATUS_OPENING_PERIOD',
        'SECURITY_TRADING_STATUS_CLOSING_PERIOD',
        'SECURITY_TRADING_STATUS_BREAK_IN_TRADING',
        'SECURITY_TRADING_STATUS_NORMAL_TRADING',
        'SECURITY_TRADING_STATUS_CLOSING_AUCTION',
        'SECURITY_TRADING_STATUS_DARK_POOL_AUCTION',
        'SECURITY_TRADING_STATUS_DISCRETE_AUCTION',
        'SECURITY_TRADING_STATUS_OPENING_AUCTION_PERIOD',
        'SECURITY_TRADING_STATUS_TRADING_AT_CLOSING_AUCTION_PRICE',
        'SECURITY_TRADING_STATUS_SESSION_ASSIGNED',
        'SECURITY_TRADING_STATUS_SESSION_CLOSE',
        'SECURITY_TRADING_STATUS_SESSION_OPEN',
        'SECURITY_TRADING_STATUS_DEALER_NORMAL_TRADING',
        'SECURITY_TRADING_STATUS_DEALER_BREAK_IN_TRADING',
        'SECURITY_TRADING_STATUS_DEALER_NOT_AVAILABLE_FOR_TRADING',
    ])
    .register(z.globalRegistry, {
        description:
            '- SECURITY_TRADING_STATUS_UNSPECIFIED: Торговый статус не определен.\n - SECURITY_TRADING_STATUS_NOT_AVAILABLE_FOR_TRADING: Недоступен для торгов.\n - SECURITY_TRADING_STATUS_OPENING_PERIOD: Период открытия торгов.\n - SECURITY_TRADING_STATUS_CLOSING_PERIOD: Период закрытия торгов.\n - SECURITY_TRADING_STATUS_BREAK_IN_TRADING: Перерыв в торговле.\n - SECURITY_TRADING_STATUS_NORMAL_TRADING: Нормальная торговля.\n - SECURITY_TRADING_STATUS_CLOSING_AUCTION: Аукцион закрытия.\n - SECURITY_TRADING_STATUS_DARK_POOL_AUCTION: Аукцион крупных пакетов.\n - SECURITY_TRADING_STATUS_DISCRETE_AUCTION: Дискретный аукцион.\n - SECURITY_TRADING_STATUS_OPENING_AUCTION_PERIOD: Аукцион открытия.\n - SECURITY_TRADING_STATUS_TRADING_AT_CLOSING_AUCTION_PRICE: Период торгов по цене аукциона закрытия.\n - SECURITY_TRADING_STATUS_SESSION_ASSIGNED: Сессия назначена.\n - SECURITY_TRADING_STATUS_SESSION_CLOSE: Сессия закрыта.\n - SECURITY_TRADING_STATUS_SESSION_OPEN: Сессия открыта.\n - SECURITY_TRADING_STATUS_DEALER_NORMAL_TRADING: Доступна торговля в режиме внутренней ликвидности брокера.\n - SECURITY_TRADING_STATUS_DEALER_BREAK_IN_TRADING: Перерыв торговли в режиме внутренней ликвидности брокера.\n - SECURITY_TRADING_STATUS_DEALER_NOT_AVAILABLE_FOR_TRADING: Недоступна торговля в режиме внутренней ликвидности брокера.',
    });

/**
 * Объект передачи информации об облигации.
 */
export const zV1Bond = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций в шорт.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        couponQuantityPerYear: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Количество выплат по купонам в год.',
            }),
        ),
        maturityDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата погашения облигации по UTC.',
            }),
        ),
        nominal: z.optional(zV1MoneyValue),
        initialNominal: z.optional(zV1MoneyValue),
        stateRegDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата выпуска облигации по UTC.',
            }),
        ),
        placementDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата размещения по UTC.',
            }),
        ),
        placementPrice: z.optional(zV1MoneyValue),
        aciValue: z.optional(zV1MoneyValue),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Код страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор экономики.',
            }),
        ),
        issueKind: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Форма выпуска. Возможные значения: <br/>**documentary** — документарная; <br/>**non_documentary** — бездокументарная.',
            }),
        ),
        issueSize: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Размер выпуска.',
            }),
        ),
        issueSizePlan: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Плановый размер выпуска.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        floatingCouponFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак облигации с плавающим купоном.',
            }),
        ),
        perpetualFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак бессрочной облигации.',
            }),
        ),
        amortizationFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак облигации с амортизацией долга.',
            }),
        ),
        minPriceIncrement: z.optional(zV1Quotation),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Параметр указывает на возможность торговать инструментом через API.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        assetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор актива.',
            }),
        ),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        subordinatedFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак субординированной облигации.',
            }),
        ),
        liquidityFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг достаточной ликвидности.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        riskLevel: z.optional(zV1RiskLevel),
        brand: z.optional(zV1BrandData),
        bondType: z.optional(zV1BondType),
        callDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата погашения облигации.',
            }),
        ),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации об облигации.',
    });

/**
 * Информация об облигации.
 */
export const zV1BondResponse = z
    .object({
        instrument: z.optional(zV1Bond),
    })
    .register(z.globalRegistry, {
        description: 'Информация об облигации.',
    });

/**
 * Список облигаций.
 */
export const zV1BondsResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1Bond).register(z.globalRegistry, {
                description: 'Массив облигаций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список облигаций.',
    });

/**
 * Объект передачи информации о валюте.
 */
export const zV1Currency = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций в шорт.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        nominal: z.optional(zV1MoneyValue),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Код страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        isoCurrencyName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Строковый ISO-код валюты.',
            }),
        ),
        minPriceIncrement: z.optional(zV1Quotation),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Параметр указывает на возможность торговать инструментом через API.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        brand: z.optional(zV1BrandData),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации о валюте.',
    });

/**
 * Данные по валютам.
 */
export const zV1CurrenciesResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1Currency).register(z.globalRegistry, {
                description: 'Массив валют.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по валютам.',
    });

/**
 * Данные по валюте.
 */
export const zV1CurrencyResponse = z
    .object({
        instrument: z.optional(zV1Currency),
    })
    .register(z.globalRegistry, {
        description: 'Данные по валюте.',
    });

/**
 * Объект передачи информации об инвестиционном фонде.
 */
export const zV1Etf = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций в шорт.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        fixedCommission: z.optional(zV1Quotation),
        focusType: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Возможные значения: <br/>**equity** — акции;<br/>**fixed_income** — облигации;<br/>**mixed_allocation** — смешанный;<br/>**money_market** — денежный рынок;<br/>**real_estate** — недвижимость;<br/>**commodity** — товары;<br/>**specialty** — специальный;<br/>**private_equity** — private equity;<br/>**alternative_investment** — альтернативные инвестиции.',
            }),
        ),
        releasedDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата выпуска по UTC.',
            }),
        ),
        numShares: z.optional(zV1Quotation),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Код страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор экономики.',
            }),
        ),
        rebalancingFreq: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Частота ребалансировки.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        minPriceIncrement: z.optional(zV1Quotation),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Параметр указывает на возможность торговать инструментом через API.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        assetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор актива.',
            }),
        ),
        instrumentExchange: z.optional(zV1InstrumentExchangeType),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'ФлагФлаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        liquidityFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг достаточной ликвидности.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        brand: z.optional(zV1BrandData),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации об инвестиционном фонде.',
    });

/**
 * Данные по фонду.
 */
export const zV1EtfResponse = z
    .object({
        instrument: z.optional(zV1Etf),
    })
    .register(z.globalRegistry, {
        description: 'Данные по фонду.',
    });

/**
 * Данные по фондам.
 */
export const zV1EtfsResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1Etf).register(z.globalRegistry, {
                description: 'Массив фондов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по фондам.',
    });

/**
 * Объект передачи информации о фьючерсе.
 */
export const zV1Future = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций шорт.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        firstTradeDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата начала обращения контракта по UTC.',
            }),
        ),
        lastTradeDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата по UTC, до которой возможно проведение операций с фьючерсом.',
            }),
        ),
        futuresType: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Тип фьючерса. Возможные значения: <br/>**physical_delivery** — физические поставки; <br/>**cash_settlement** — денежный эквивалент.',
            }),
        ),
        assetType: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Тип актива. Возможные значения: <br/>**commodity** — товар; <br/>**currency** — валюта; <br/>**security** — ценная бумага; <br/>**index** — индекс.',
            }),
        ),
        basicAsset: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Основной актив.',
            }),
        ),
        basicAssetSize: z.optional(zV1Quotation),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Код страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор экономики.',
            }),
        ),
        expirationDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата истечения срока в часов поясе UTC.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        minPriceIncrement: z.optional(zV1Quotation),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Параметр указывает на возможность торговать инструментом через API.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        basicAssetPositionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции основного инструмента.',
            }),
        ),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        initialMarginOnBuy: z.optional(zV1MoneyValue),
        initialMarginOnSell: z.optional(zV1MoneyValue),
        minPriceIncrementAmount: z.optional(zV1Quotation),
        brand: z.optional(zV1BrandData),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации о фьючерсе.',
    });

/**
 * Данные по фьючерсу.
 */
export const zV1FutureResponse = z
    .object({
        instrument: z.optional(zV1Future),
    })
    .register(z.globalRegistry, {
        description: 'Данные по фьючерсу.',
    });

/**
 * Данные по фьючерсам.
 */
export const zV1FuturesResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1Future).register(z.globalRegistry, {
                description: 'Массив фьючерсов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по фьючерсам.',
    });

/**
 * Информация о торговом статусе.
 */
export const zV1GetTradingStatusResponse = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        limitOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления лимитной заявки по инструменту.',
            }),
        ),
        marketOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления рыночной заявки по инструменту.',
            }),
        ),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности торгов через API.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        bestpriceOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности завяки по лучшей цене.',
            }),
        ),
        onlyBestPrice: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности только заявки по лучшей цене.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о торговом статусе.',
    });

/**
 * Информация о торговом статусе.
 */
export const zV1GetTradingStatusesResponse = z
    .object({
        tradingStatuses: z.optional(
            z.array(zV1GetTradingStatusResponse).register(z.globalRegistry, {
                description: 'Массив информации о торговых статусах.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о торговом статусе.',
    });

/**
 * Объект передачи основной информации об инструменте.
 */
export const zV1Instrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код инструмента.',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций в шорт.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Код страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        instrumentType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип инструмента.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        minPriceIncrement: z.optional(zV1Quotation),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Параметр указывает на возможность торговать инструментом через API.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        assetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор актива.',
            }),
        ),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        instrumentKind: z.optional(zV1InstrumentType),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        brand: z.optional(zV1BrandData),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи основной информации об инструменте.',
    });

/**
 * Данные по инструменту.
 */
export const zV1InstrumentResponse = z
    .object({
        instrument: z.optional(zV1Instrument),
    })
    .register(z.globalRegistry, {
        description: 'Данные по инструменту.',
    });

/**
 * Опцион.
 */
export const zV1Option = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код.',
            }),
        ),
        basicAssetPositionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции основного инструмента.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        realExchange: z.optional(zV1RealExchange),
        direction: z.optional(zV1OptionDirection),
        paymentType: z.optional(zV1OptionPaymentType),
        style: z.optional(zV1OptionStyle),
        settlementType: z.optional(zV1OptionSettlementType),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта.',
            }),
        ),
        settlementCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта, в которой оценивается контракт.',
            }),
        ),
        assetType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип актива.',
            }),
        ),
        basicAsset: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Основной актив.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Код страны рисков.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование страны рисков.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор экономики.',
            }),
        ),
        brand: z.optional(zV1BrandData),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Количество бумаг в лоте.',
            }),
        ),
        basicAssetSize: z.optional(zV1Quotation),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        minPriceIncrement: z.optional(zV1Quotation),
        strikePrice: z.optional(zV1MoneyValue),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
        expirationDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата истечения срока в формате UTC.',
            }),
        ),
        firstTradeDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата начала обращения контракта в формате UTC.',
            }),
        ),
        lastTradeDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата исполнения в формате UTC.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи в формате UTC.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи в формате UTC.',
            }),
        ),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций шорт.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Возможность покупки или продажи на ИИС.',
            }),
        ),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Возможность торговать инструментом через API.',
            }),
        ),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Опцион.',
    });

/**
 * Данные по опциону.
 */
export const zV1OptionResponse = z
    .object({
        instrument: z.optional(zV1Option),
    })
    .register(z.globalRegistry, {
        description: 'Данные по опциону.',
    });

/**
 * Данные по опционам.
 */
export const zV1OptionsResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1Option).register(z.globalRegistry, {
                description: 'Массив данных по опциону.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по опционам.',
    });

/**
 * Тип акций.
 *
 * - SHARE_TYPE_UNSPECIFIED: Значение не определено.
 * - SHARE_TYPE_COMMON: Обыкновенная.
 * - SHARE_TYPE_PREFERRED: Привилегированная.
 * - SHARE_TYPE_ADR: Американские депозитарные расписки.
 * - SHARE_TYPE_GDR: Глобальные депозитарные расписки.
 * - SHARE_TYPE_MLP: Товарищество с ограниченной ответственностью.
 * - SHARE_TYPE_NY_REG_SHRS: Акции из реестра Нью-Йорка.
 * - SHARE_TYPE_CLOSED_END_FUND: Закрытый инвестиционный фонд.
 * - SHARE_TYPE_REIT: Траст недвижимости.
 */
export const zV1ShareType = z
    .enum([
        'SHARE_TYPE_UNSPECIFIED',
        'SHARE_TYPE_COMMON',
        'SHARE_TYPE_PREFERRED',
        'SHARE_TYPE_ADR',
        'SHARE_TYPE_GDR',
        'SHARE_TYPE_MLP',
        'SHARE_TYPE_NY_REG_SHRS',
        'SHARE_TYPE_CLOSED_END_FUND',
        'SHARE_TYPE_REIT',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип акций.\n\n - SHARE_TYPE_UNSPECIFIED: Значение не определено.\n - SHARE_TYPE_COMMON: Обыкновенная.\n - SHARE_TYPE_PREFERRED: Привилегированная.\n - SHARE_TYPE_ADR: Американские депозитарные расписки.\n - SHARE_TYPE_GDR: Глобальные депозитарные расписки.\n - SHARE_TYPE_MLP: Товарищество с ограниченной ответственностью.\n - SHARE_TYPE_NY_REG_SHRS: Акции из реестра Нью-Йорка.\n - SHARE_TYPE_CLOSED_END_FUND: Закрытый инвестиционный фонд.\n - SHARE_TYPE_REIT: Траст недвижимости.',
    });

/**
 * Акция.
 */
export const zV1AssetShare = z
    .object({
        type: z.optional(zV1ShareType),
        issueSize: z.optional(zV1Quotation),
        nominal: z.optional(zV1Quotation),
        nominalCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта номинала.',
            }),
        ),
        primaryIndex: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Индекс (Bloomberg).',
            }),
        ),
        dividendRate: z.optional(zV1Quotation),
        preferredShareType: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип привилегированных акций.',
            }),
        ),
        ipoDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата IPO.',
            }),
        ),
        registryDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата регистрации.',
            }),
        ),
        divYieldFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак наличия дивидендной доходности.',
            }),
        ),
        issueKind: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Форма выпуска ФИ.',
            }),
        ),
        placementDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата размещения акции.',
            }),
        ),
        represIsin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN базового актива.',
            }),
        ),
        issueSizePlan: z.optional(zV1Quotation),
        totalFloat: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Акция.',
    });

/**
 * Объект передачи информации об акции.
 */
export const zV1Share = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        lot: z.optional(z.int()),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        klong: z.optional(zV1Quotation),
        kshort: z.optional(zV1Quotation),
        dlong: z.optional(zV1Quotation),
        dshort: z.optional(zV1Quotation),
        dlongMin: z.optional(zV1Quotation),
        dshortMin: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций в шорт.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Tорговая площадка (секция биржи).',
            }),
        ),
        ipoDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата IPO акции по UTC.',
            }),
        ),
        issueSize: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Размер выпуска.',
            }),
        ),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Код страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор экономики.',
            }),
        ),
        issueSizePlan: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Плановый размер выпуска.',
            }),
        ),
        nominal: z.optional(zV1MoneyValue),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        otcFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        divYieldFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак наличия дивидендной доходности.',
            }),
        ),
        shareType: z.optional(zV1ShareType),
        minPriceIncrement: z.optional(zV1Quotation),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Возможность торговать инструментом через API.',
            }),
        ),
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции инструмента.',
            }),
        ),
        assetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор актива.',
            }),
        ),
        instrumentExchange: z.optional(zV1InstrumentExchangeType),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг, отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        blockedTcaFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг заблокированного ТКС.',
            }),
        ),
        liquidityFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг достаточной ликвидности.',
            }),
        ),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        brand: z.optional(zV1BrandData),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации об акции.',
    });

/**
 * Данные по акции.
 */
export const zV1ShareResponse = z
    .object({
        instrument: z.optional(zV1Share),
    })
    .register(z.globalRegistry, {
        description: 'Данные по акции.',
    });

/**
 * Данные по акциям.
 */
export const zV1SharesResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1Share).register(z.globalRegistry, {
                description: 'Массив акций.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по акциям.',
    });

/**
 * Направление сигнала.
 *
 * - SIGNAL_DIRECTION_UNSPECIFIED: Не определен.
 * - SIGNAL_DIRECTION_BUY: Покупка.
 * - SIGNAL_DIRECTION_SELL: Продажа.
 */
export const zV1SignalDirection = z
    .enum(['SIGNAL_DIRECTION_UNSPECIFIED', 'SIGNAL_DIRECTION_BUY', 'SIGNAL_DIRECTION_SELL'])
    .register(z.globalRegistry, {
        description:
            'Направление сигнала.\n\n - SIGNAL_DIRECTION_UNSPECIFIED: Не определен.\n - SIGNAL_DIRECTION_BUY: Покупка.\n - SIGNAL_DIRECTION_SELL: Продажа.',
    });

/**
 * Сигнал.
 */
export const zV1Signal = z
    .object({
        signalId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор сигнала.',
        }),
        strategyId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор стратегии.',
        }),
        strategyName: z.string().register(z.globalRegistry, {
            description: 'Название стратегии.',
        }),
        instrumentUid: z.string().register(z.globalRegistry, {
            description: 'Идентификатор бумаги.',
        }),
        createDt: z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время создания сигнала по UTC.',
        }),
        direction: zV1SignalDirection,
        initialPrice: zV1Quotation,
        info: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Дополнительная информация о сигнале.',
            }),
        ),
        name: z.string().register(z.globalRegistry, {
            description: 'Название сигнала.',
        }),
        targetPrice: zV1Quotation,
        endDt: z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время дедлайна сигнала по UTC.',
        }),
        probability: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Вероятность сигнала.',
            }),
        ),
        stoploss: z.optional(zV1Quotation),
        closePrice: z.optional(zV1Quotation),
        closeDt: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время закрытия сигнала по UTC.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Сигнал.',
    });

/**
 * Сигналы.
 */
export const zV1GetSignalsResponse = z
    .object({
        signals: z.optional(
            z.array(zV1Signal).register(z.globalRegistry, {
                description: 'Массив сигналов.',
            }),
        ),
        paging: z.optional(zV1PageResponse),
    })
    .register(z.globalRegistry, {
        description: 'Сигналы.',
    });

/**
 * Статус сигнала.
 *
 * - SIGNAL_STATE_UNSPECIFIED: Не определен.
 * - SIGNAL_STATE_ACTIVE: Активный сигнал.
 * - SIGNAL_STATE_CLOSED: Закрытый сигнал.
 * - SIGNAL_STATE_ALL: Все состояния.
 */
export const zV1SignalState = z
    .enum([
        'SIGNAL_STATE_UNSPECIFIED',
        'SIGNAL_STATE_ACTIVE',
        'SIGNAL_STATE_CLOSED',
        'SIGNAL_STATE_ALL',
    ])
    .register(z.globalRegistry, {
        description:
            'Статус сигнала.\n\n - SIGNAL_STATE_UNSPECIFIED: Не определен.\n - SIGNAL_STATE_ACTIVE: Активный сигнал.\n - SIGNAL_STATE_CLOSED: Закрытый сигнал.\n - SIGNAL_STATE_ALL: Все состояния.',
    });

/**
 * Направление сделки стоп-заявки.
 *
 * - STOP_ORDER_DIRECTION_UNSPECIFIED: Значение не указано.
 * - STOP_ORDER_DIRECTION_BUY: Покупка.
 * - STOP_ORDER_DIRECTION_SELL: Продажа.
 */
export const zV1StopOrderDirection = z
    .enum([
        'STOP_ORDER_DIRECTION_UNSPECIFIED',
        'STOP_ORDER_DIRECTION_BUY',
        'STOP_ORDER_DIRECTION_SELL',
    ])
    .register(z.globalRegistry, {
        description:
            'Направление сделки стоп-заявки.\n\n - STOP_ORDER_DIRECTION_UNSPECIFIED: Значение не указано.\n - STOP_ORDER_DIRECTION_BUY: Покупка.\n - STOP_ORDER_DIRECTION_SELL: Продажа.',
    });

/**
 * Тип экспирации стоп-заявке.
 *
 * - STOP_ORDER_EXPIRATION_TYPE_UNSPECIFIED: Значение не указано.
 * - STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL: Действительно до отмены.
 * - STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_DATE: Действительно до даты снятия.
 */
export const zV1StopOrderExpirationType = z
    .enum([
        'STOP_ORDER_EXPIRATION_TYPE_UNSPECIFIED',
        'STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL',
        'STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_DATE',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип экспирации стоп-заявке.\n\n - STOP_ORDER_EXPIRATION_TYPE_UNSPECIFIED: Значение не указано.\n - STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL: Действительно до отмены.\n - STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_DATE: Действительно до даты снятия.',
    });

/**
 * Статус стоп-заяки.
 *
 * - STOP_ORDER_STATUS_UNSPECIFIED: Значение не указано.
 * - STOP_ORDER_STATUS_ALL: Все заявки.
 * - STOP_ORDER_STATUS_ACTIVE: Активные заявки.
 * - STOP_ORDER_STATUS_EXECUTED: Исполненные заявки.
 * - STOP_ORDER_STATUS_CANCELED: Отмененные заявки.
 * - STOP_ORDER_STATUS_EXPIRED: Истекшие заявки.
 */
export const zV1StopOrderStatusOption = z
    .enum([
        'STOP_ORDER_STATUS_UNSPECIFIED',
        'STOP_ORDER_STATUS_ALL',
        'STOP_ORDER_STATUS_ACTIVE',
        'STOP_ORDER_STATUS_EXECUTED',
        'STOP_ORDER_STATUS_CANCELED',
        'STOP_ORDER_STATUS_EXPIRED',
    ])
    .register(z.globalRegistry, {
        description:
            'Статус стоп-заяки.\n\n - STOP_ORDER_STATUS_UNSPECIFIED: Значение не указано.\n - STOP_ORDER_STATUS_ALL: Все заявки.\n - STOP_ORDER_STATUS_ACTIVE: Активные заявки.\n - STOP_ORDER_STATUS_EXECUTED: Исполненные заявки.\n - STOP_ORDER_STATUS_CANCELED: Отмененные заявки.\n - STOP_ORDER_STATUS_EXPIRED: Истекшие заявки.',
    });

/**
 * Запрос получения списка активных стоп-заявок.
 */
export const zV1GetStopOrdersRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета клиента.',
        }),
        status: z.optional(zV1StopOrderStatusOption),
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Левая граница.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Правая граница.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос получения списка активных стоп-заявок.',
    });

/**
 * Тип стоп-заявки.
 *
 * - STOP_ORDER_TYPE_UNSPECIFIED: Значение не указано.
 * - STOP_ORDER_TYPE_TAKE_PROFIT: `Take-profit`-заявка.
 * - STOP_ORDER_TYPE_STOP_LOSS: `Stop-loss`-заявка.
 * - STOP_ORDER_TYPE_STOP_LIMIT: `Stop-limit`-заявка.
 */
export const zV1StopOrderType = z
    .enum([
        'STOP_ORDER_TYPE_UNSPECIFIED',
        'STOP_ORDER_TYPE_TAKE_PROFIT',
        'STOP_ORDER_TYPE_STOP_LOSS',
        'STOP_ORDER_TYPE_STOP_LIMIT',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип стоп-заявки.\n\n - STOP_ORDER_TYPE_UNSPECIFIED: Значение не указано.\n - STOP_ORDER_TYPE_TAKE_PROFIT: `Take-profit`-заявка.\n - STOP_ORDER_TYPE_STOP_LOSS: `Stop-loss`-заявка.\n - STOP_ORDER_TYPE_STOP_LIMIT: `Stop-limit`-заявка.',
    });

/**
 * Тип стратегии.
 *
 * - STRATEGY_TYPE_UNSPECIFIED: Не определен.
 * - STRATEGY_TYPE_TECHNICAL: Техническая стратегия.
 * - STRATEGY_TYPE_FUNDAMENTAL: Фундаментальная стратегия.
 */
export const zV1StrategyType = z
    .enum(['STRATEGY_TYPE_UNSPECIFIED', 'STRATEGY_TYPE_TECHNICAL', 'STRATEGY_TYPE_FUNDAMENTAL'])
    .register(z.globalRegistry, {
        description:
            'Тип стратегии.\n\n - STRATEGY_TYPE_UNSPECIFIED: Не определен.\n - STRATEGY_TYPE_TECHNICAL: Техническая стратегия.\n - STRATEGY_TYPE_FUNDAMENTAL: Фундаментальная стратегия.',
    });

/**
 * Запрос сигналов.
 */
export const zV1GetSignalsRequest = z
    .object({
        signalId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор сигнала.',
            }),
        ),
        strategyId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор стратегии.',
            }),
        ),
        strategyType: z.optional(zV1StrategyType),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор бумаги.',
            }),
        ),
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата начала запрашиваемого интервала по UTC.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата конца запрашиваемого интервала по UTC.',
            }),
        ),
        direction: z.optional(zV1SignalDirection),
        active: z.optional(zV1SignalState),
        paging: z.optional(zV1Page),
    })
    .register(z.globalRegistry, {
        description: 'Запрос сигналов.',
    });

/**
 * Стратегия
 */
export const zV1Strategy = z.object({
    strategyId: z.string().register(z.globalRegistry, {
        description: 'Идентификатор стратегии.',
    }),
    strategyName: z.string().register(z.globalRegistry, {
        description: 'Название стратегии.',
    }),
    strategyDescription: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Описание стратегии.',
        }),
    ),
    strategyUrl: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Ссылка на страницу с описанием стратегии.',
        }),
    ),
    strategyType: zV1StrategyType,
    activeSignals: z.int().register(z.globalRegistry, {
        description: 'Количество активных сигналов.',
    }),
    totalSignals: z.int().register(z.globalRegistry, {
        description: 'Общее количество сигналов.',
    }),
    timeInPosition: z.string().register(z.globalRegistry, {
        description: 'Среднее время нахождения сигнала в позиции.',
    }),
    averageSignalYield: zV1Quotation,
    averageSignalYieldYear: zV1Quotation,
    yield: zV1Quotation,
    yieldYear: zV1Quotation,
});

/**
 * Стратегии
 */
export const zV1GetStrategiesResponse = z.object({
    strategies: z.optional(z.array(zV1Strategy)),
});

/**
 * Лимит stream-соединений.
 */
export const zV1StreamLimit = z
    .object({
        limit: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Максимальное количество stream-соединений.',
            }),
        ),
        streams: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description: 'Названия stream-методов.',
            }),
        ),
        open: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Текущее количество открытых stream-соединений.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Лимит stream-соединений.',
    });

/**
 * Объект передачи информации о структурной ноте.
 */
export const zV1StructuredNote = z
    .object({
        uid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор инструмента.',
            }),
        ),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор инструмента.',
            }),
        ),
        name: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название инструмента.',
            }),
        ),
        assetUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор актива.',
            }),
        ),
        positionUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор позиции.',
            }),
        ),
        minPriceIncrement: z.optional(zV1Quotation),
        lot: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Лотность инструмента.',
            }),
        ),
        nominal: z.optional(zV1MoneyValue),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта расчетов.',
            }),
        ),
        maturityDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата погашения облигации в формате UTC.',
            }),
        ),
        placementDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата размещения в формате UTC.',
            }),
        ),
        issueKind: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Форма выпуска.',
            }),
        ),
        issueSize: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Размер выпуска.',
            }),
        ),
        issueSizePlan: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Плановый размер выпуска.',
            }),
        ),
        dlongClient: z.optional(zV1Quotation),
        dshortClient: z.optional(zV1Quotation),
        shortEnabledFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для операций в шорт.',
            }),
        ),
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Торговая площадка (секция биржи).',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        apiTradeAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности торгов по бумаге через API.',
            }),
        ),
        buyAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для покупки.',
            }),
        ),
        sellAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности для продажи.',
            }),
        ),
        limitOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления лимитной заявки по инструменту.',
            }),
        ),
        marketOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления рыночной заявки по инструменту.',
            }),
        ),
        bestpriceOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления bestprice заявки по инструменту.',
            }),
        ),
        weekendFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг отображающий доступность торговли инструментом по выходным.',
            }),
        ),
        liquidityFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг достаточной ликвидности.',
            }),
        ),
        forIisFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Возможность покупки/продажи на ИИС.',
            }),
        ),
        forQualInvestorFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.',
            }),
        ),
        pawnshopListFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак ФИ, включенного в ломбардный список.',
            }),
        ),
        realExchange: z.optional(zV1RealExchange),
        first1minCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой минутной свечи.',
            }),
        ),
        first1dayCandleDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата первой дневной свечи.',
            }),
        ),
        borrowName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Название заемщика.',
            }),
        ),
        type: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип структурной ноты.',
            }),
        ),
        logicPortfolio: z.optional(zStructuredNoteLogicPortfolio),
        assetType: z.optional(zV1AssetType),
        basicAssets: z.optional(
            z.array(zStructuredNoteBasicAsset).register(z.globalRegistry, {
                description: 'Базовые активы, входящие в ноту.',
            }),
        ),
        safetyBarrier: z.optional(zV1Quotation),
        couponPeriodBase: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Базис расчета НКД.',
            }),
        ),
        observationPrinciple: z.optional(zStructuredNoteObservationPrinciple),
        observationFrequency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Частота наблюдений.',
            }),
        ),
        initialPriceFixingDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата фиксации цен базовых активов.',
            }),
        ),
        yield: z.optional(
            z.array(zStructuredNoteYield).register(z.globalRegistry, {
                description: 'Доходность по ноте в годовом выражении.',
            }),
        ),
        couponSavingFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак сохранения купонов.',
            }),
        ),
        sector: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Сектор экономики.',
            }),
        ),
        countryOfRisk: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Код страны рисков.',
            }),
        ),
        countryOfRiskName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование страны рисков.',
            }),
        ),
        logoName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Имя файла логотипа эмитента.',
            }),
        ),
        requiredTests: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description:
                    'Тесты, которые необходимо пройти клиенту, чтобы совершать покупки по бумаге.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Объект передачи информации о структурной ноте.',
    });

/**
 * Данные по структурной ноте.
 */
export const zV1StructuredNoteResponse = z
    .object({
        instrument: z.optional(zV1StructuredNote),
    })
    .register(z.globalRegistry, {
        description: 'Данные по структурной ноте.',
    });

/**
 * Данные по структурным нотам.
 */
export const zV1StructuredNotesResponse = z
    .object({
        instruments: z.optional(
            z.array(zV1StructuredNote).register(z.globalRegistry, {
                description: 'Массив структурных нот.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по структурным нотам.',
    });

/**
 * Тип структурной ноты.
 *
 * - SP_TYPE_UNSPECIFIED: Тип не определен.
 * - SP_TYPE_DELIVERABLE: Поставочный.
 * - SP_TYPE_NON_DELIVERABLE: Беспоставочный.
 */
export const zV1StructuredProductType = z
    .enum(['SP_TYPE_UNSPECIFIED', 'SP_TYPE_DELIVERABLE', 'SP_TYPE_NON_DELIVERABLE'])
    .register(z.globalRegistry, {
        description:
            'Тип структурной ноты.\n\n - SP_TYPE_UNSPECIFIED: Тип не определен.\n - SP_TYPE_DELIVERABLE: Поставочный.\n - SP_TYPE_NON_DELIVERABLE: Беспоставочный.',
    });

/**
 * Структурная нота.
 */
export const zV1AssetStructuredProduct = z
    .object({
        borrowName: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование заемщика.',
            }),
        ),
        nominal: z.optional(zV1Quotation),
        nominalCurrency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта номинала.',
            }),
        ),
        type: z.optional(zV1StructuredProductType),
        logicPortfolio: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Стратегия портфеля.',
            }),
        ),
        assetType: z.optional(zV1AssetType),
        basicAsset: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Вид базового актива в зависимости от типа базового актива.',
            }),
        ),
        safetyBarrier: z.optional(zV1Quotation),
        maturityDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата погашения.',
            }),
        ),
        issueSizePlan: z.optional(zV1Quotation),
        issueSize: z.optional(zV1Quotation),
        placementDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата размещения ноты.',
            }),
        ),
        issueKind: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Форма выпуска.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Структурная нота.',
    });

/**
 * Ценная бумага.
 */
export const zV1AssetSecurity = z
    .object({
        isin: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'ISIN-идентификатор ценной бумаги.',
            }),
        ),
        type: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тип ценной бумаги.',
            }),
        ),
        instrumentKind: z.optional(zV1InstrumentType),
        share: z.optional(zV1AssetShare),
        bond: z.optional(zV1AssetBond),
        sp: z.optional(zV1AssetStructuredProduct),
        etf: z.optional(zV1AssetEtf),
        clearingCertificate: z.optional(zV1AssetClearingCertificate),
    })
    .register(z.globalRegistry, {
        description: 'Ценная бумага.',
    });

export const zV1AssetFull = z.object({
    uid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор актива.',
        }),
    ),
    type: z.optional(zV1AssetType),
    name: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Наименование актива.',
        }),
    ),
    nameBrief: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Короткое наименование актива.',
        }),
    ),
    description: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Описание актива.',
        }),
    ),
    deletedAt: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время удаления актива.',
        }),
    ),
    requiredTests: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description: 'Тестирование клиентов.',
        }),
    ),
    currency: z.optional(zV1AssetCurrency),
    security: z.optional(zV1AssetSecurity),
    gosRegCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Номер государственной регистрации.',
        }),
    ),
    cfi: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код CFI.',
        }),
    ),
    codeNsd: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код НРД инструмента.',
        }),
    ),
    status: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Статус актива.',
        }),
    ),
    brand: z.optional(zV1Brand),
    updatedAt: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата и время последнего обновления записи.',
        }),
    ),
    brCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код типа ц.б. по классификации Банка России.',
        }),
    ),
    brCodeName: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Наименование кода типа ц.б. по классификации Банка России.',
        }),
    ),
    instruments: z.optional(
        z.array(zV1AssetInstrument).register(z.globalRegistry, {
            description: 'Массив идентификаторов инструментов.',
        }),
    ),
});

/**
 * Данные по активу.
 */
export const zV1AssetResponse = z
    .object({
        asset: z.optional(zV1AssetFull),
    })
    .register(z.globalRegistry, {
        description: 'Данные по активу.',
    });

/**
 * Тип операции со списком подписок.
 *
 * - SUBSCRIPTION_ACTION_UNSPECIFIED: Статус подписки не определен.
 * - SUBSCRIPTION_ACTION_SUBSCRIBE: Подписаться.
 * - SUBSCRIPTION_ACTION_UNSUBSCRIBE: Отписаться.
 */
export const zV1SubscriptionAction = z
    .enum([
        'SUBSCRIPTION_ACTION_UNSPECIFIED',
        'SUBSCRIPTION_ACTION_SUBSCRIBE',
        'SUBSCRIPTION_ACTION_UNSUBSCRIBE',
    ])
    .register(z.globalRegistry, {
        description:
            'Тип операции со списком подписок.\n\n - SUBSCRIPTION_ACTION_UNSPECIFIED: Статус подписки не определен.\n - SUBSCRIPTION_ACTION_SUBSCRIBE: Подписаться.\n - SUBSCRIPTION_ACTION_UNSUBSCRIBE: Отписаться.',
    });

/**
 * Изменение статуса подписки на торговый статус инструмента.
 */
export const zV1SubscribeInfoRequest = z
    .object({
        subscriptionAction: z.optional(zV1SubscriptionAction),
        instruments: z.optional(
            z.array(zV1InfoInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов для подписки на торговый статус.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Изменение статуса подписки на торговый статус инструмента.',
    });

/**
 * Изменение статуса подписки на цену последней сделки по инструменту.
 */
export const zV1SubscribeLastPriceRequest = z
    .object({
        subscriptionAction: z.optional(zV1SubscriptionAction),
        instruments: z.optional(
            z.array(zV1LastPriceInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов для подписки на цену последней сделки.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Изменение статуса подписки на цену последней сделки по инструменту.',
    });

/**
 * Запрос на изменение статуса подписки на стаканы.
 */
export const zV1SubscribeOrderBookRequest = z
    .object({
        subscriptionAction: z.optional(zV1SubscriptionAction),
        instruments: z.optional(
            z.array(zV1OrderBookInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов для подписки на стаканы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос на изменение статуса подписки на стаканы.',
    });

/**
 * Интервал свечи.
 *
 * - SUBSCRIPTION_INTERVAL_UNSPECIFIED: Интервал свечи не определен.
 * - SUBSCRIPTION_INTERVAL_ONE_MINUTE: Минутные свечи.
 * - SUBSCRIPTION_INTERVAL_FIVE_MINUTES: Пятиминутные свечи.
 * - SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES: Пятнадцатиминутные свечи.
 * - SUBSCRIPTION_INTERVAL_ONE_HOUR: Часовые свечи.
 * - SUBSCRIPTION_INTERVAL_ONE_DAY: Дневные свечи.
 * - SUBSCRIPTION_INTERVAL_2_MIN: Двухминутные свечи.
 * - SUBSCRIPTION_INTERVAL_3_MIN: Трехминутные свечи.
 * - SUBSCRIPTION_INTERVAL_10_MIN: Десятиминутные свечи.
 * - SUBSCRIPTION_INTERVAL_30_MIN: Тридцатиминутные свечи.
 * - SUBSCRIPTION_INTERVAL_2_HOUR: Двухчасовые свечи.
 * - SUBSCRIPTION_INTERVAL_4_HOUR: Четырехчасовые свечи.
 * - SUBSCRIPTION_INTERVAL_WEEK: Недельные свечи.
 * - SUBSCRIPTION_INTERVAL_MONTH: Месячные свечи.
 */
export const zV1SubscriptionInterval = z
    .enum([
        'SUBSCRIPTION_INTERVAL_UNSPECIFIED',
        'SUBSCRIPTION_INTERVAL_ONE_MINUTE',
        'SUBSCRIPTION_INTERVAL_FIVE_MINUTES',
        'SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES',
        'SUBSCRIPTION_INTERVAL_ONE_HOUR',
        'SUBSCRIPTION_INTERVAL_ONE_DAY',
        'SUBSCRIPTION_INTERVAL_2_MIN',
        'SUBSCRIPTION_INTERVAL_3_MIN',
        'SUBSCRIPTION_INTERVAL_10_MIN',
        'SUBSCRIPTION_INTERVAL_30_MIN',
        'SUBSCRIPTION_INTERVAL_2_HOUR',
        'SUBSCRIPTION_INTERVAL_4_HOUR',
        'SUBSCRIPTION_INTERVAL_WEEK',
        'SUBSCRIPTION_INTERVAL_MONTH',
    ])
    .register(z.globalRegistry, {
        description:
            'Интервал свечи.\n\n - SUBSCRIPTION_INTERVAL_UNSPECIFIED: Интервал свечи не определен.\n - SUBSCRIPTION_INTERVAL_ONE_MINUTE: Минутные свечи.\n - SUBSCRIPTION_INTERVAL_FIVE_MINUTES: Пятиминутные свечи.\n - SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES: Пятнадцатиминутные свечи.\n - SUBSCRIPTION_INTERVAL_ONE_HOUR: Часовые свечи.\n - SUBSCRIPTION_INTERVAL_ONE_DAY: Дневные свечи.\n - SUBSCRIPTION_INTERVAL_2_MIN: Двухминутные свечи.\n - SUBSCRIPTION_INTERVAL_3_MIN: Трехминутные свечи.\n - SUBSCRIPTION_INTERVAL_10_MIN: Десятиминутные свечи.\n - SUBSCRIPTION_INTERVAL_30_MIN: Тридцатиминутные свечи.\n - SUBSCRIPTION_INTERVAL_2_HOUR: Двухчасовые свечи.\n - SUBSCRIPTION_INTERVAL_4_HOUR: Четырехчасовые свечи.\n - SUBSCRIPTION_INTERVAL_WEEK: Недельные свечи.\n - SUBSCRIPTION_INTERVAL_MONTH: Месячные свечи.',
    });

/**
 * Пакет свечей в рамках стрима.
 */
export const zV1Candle = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        interval: z.optional(zV1SubscriptionInterval),
        open: z.optional(zV1Quotation),
        high: z.optional(zV1Quotation),
        low: z.optional(zV1Quotation),
        close: z.optional(zV1Quotation),
        volume: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Объем сделок в лотах.',
            }),
        ),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала интервала свечи по UTC.',
            }),
        ),
        lastTradeTs: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время последней сделки, вошедшей в свечу по UTC.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
        volumeBuy: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Объем торгов на покупку.',
            }),
        ),
        volumeSell: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Объём торгов на продажу.',
            }),
        ),
        candleSourceType: z.optional(zContractv1CandleSource),
    })
    .register(z.globalRegistry, {
        description: 'Пакет свечей в рамках стрима.',
    });

/**
 * Запрос изменения статус подписки на свечи.
 */
export const zV1CandleInstrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.',
            }),
        ),
        interval: z.optional(zV1SubscriptionInterval),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос изменения статус подписки на свечи.',
    });

/**
 * subscribeCandles | Изменения статуса подписки на свечи.
 */
export const zV1SubscribeCandlesRequest = z
    .object({
        subscriptionAction: z.optional(zV1SubscriptionAction),
        instruments: z.optional(
            z.array(zV1CandleInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов для подписки на свечи.',
            }),
        ),
        waitingClose: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг ожидания закрытия временного интервала для отправки свечи.',
            }),
        ),
        candleSourceType: z.optional(zV1GetCandlesRequestCandleSource),
    })
    .register(z.globalRegistry, {
        description: 'subscribeCandles | Изменения статуса подписки на свечи.',
    });

/**
 * Информация по подпискам
 */
export const zV1SubscriptionResponse = z.object({
    trackingId: z.optional(
        z.string().register(z.globalRegistry, {
            description:
                'Уникальный идентификатор запроса, подробнее: [tracking_id](./grpc#tracking-id).',
        }),
    ),
    status: z.optional(zV1ResultSubscriptionStatus),
    streamId: z.optional(z.string()),
    accounts: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
            description: 'Идентификаторы счетов.',
        }),
    ),
    error: z.optional(zV1ErrorDetail),
});

/**
 * Результат подписки.
 *
 * - SUBSCRIPTION_STATUS_UNSPECIFIED: Статус подписки не определен.
 * - SUBSCRIPTION_STATUS_SUCCESS: Успешно.
 * - SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND: Инструмент не найден.
 * - SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID: Некорректный статус подписки. [Список возможных значений](./marketdata#subscriptionaction).
 * - SUBSCRIPTION_STATUS_DEPTH_IS_INVALID: Некорректная глубина стакана. Доступные значения — 1, 10, 20, 30, 40, 50.
 * - SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID: Некорректный интервал свечей. [Список возможных значений](./marketdata#subscriptioninterval).
 * - SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED: Превышен лимит на общее количество подписок в рамках стрима. [Лимитная политика](./limits/).
 * - SUBSCRIPTION_STATUS_INTERNAL_ERROR: Внутренняя ошибка сервиса.
 * - SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS: Превышен лимит на количество запросов на подписки в течение установленного отрезка времени.
 * - SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND: Активная подписка не найдена. Ошибка может возникнуть только при отписке от несуществующей подписки.
 * - SUBSCRIPTION_STATUS_SOURCE_IS_INVALID: Указан некорректный источник.
 */
export const zV1SubscriptionStatus = z
    .enum([
        'SUBSCRIPTION_STATUS_UNSPECIFIED',
        'SUBSCRIPTION_STATUS_SUCCESS',
        'SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND',
        'SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID',
        'SUBSCRIPTION_STATUS_DEPTH_IS_INVALID',
        'SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID',
        'SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED',
        'SUBSCRIPTION_STATUS_INTERNAL_ERROR',
        'SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS',
        'SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND',
        'SUBSCRIPTION_STATUS_SOURCE_IS_INVALID',
    ])
    .register(z.globalRegistry, {
        description:
            'Результат подписки.\n\n - SUBSCRIPTION_STATUS_UNSPECIFIED: Статус подписки не определен.\n - SUBSCRIPTION_STATUS_SUCCESS: Успешно.\n - SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND: Инструмент не найден.\n - SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID: Некорректный статус подписки. [Список возможных значений](./marketdata#subscriptionaction).\n - SUBSCRIPTION_STATUS_DEPTH_IS_INVALID: Некорректная глубина стакана. Доступные значения — 1, 10, 20, 30, 40, 50.\n - SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID: Некорректный интервал свечей. [Список возможных значений](./marketdata#subscriptioninterval).\n - SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED: Превышен лимит на общее количество подписок в рамках стрима. [Лимитная политика](./limits/).\n - SUBSCRIPTION_STATUS_INTERNAL_ERROR: Внутренняя ошибка сервиса.\n - SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS: Превышен лимит на количество запросов на подписки в течение установленного отрезка времени.\n - SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND: Активная подписка не найдена. Ошибка может возникнуть только при отписке от несуществующей подписки.\n - SUBSCRIPTION_STATUS_SOURCE_IS_INVALID: Указан некорректный источник.',
    });

/**
 * Статус подписки на свечи.
 */
export const zV1CandleSubscription = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        interval: z.optional(zV1SubscriptionInterval),
        subscriptionStatus: z.optional(zV1SubscriptionStatus),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        waitingClose: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Флаг ожидания закрытия временного интервала для отправки свечи.',
            }),
        ),
        streamId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор открытого соединения.',
            }),
        ),
        subscriptionId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор подписки в формате `UUID`.',
            }),
        ),
        subscriptionAction: z.optional(zV1SubscriptionAction),
        candleSourceType: z.optional(zV1GetCandlesRequestCandleSource),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Статус подписки на свечи.',
    });

/**
 * Статус подписки.
 */
export const zV1InfoSubscription = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        subscriptionStatus: z.optional(zV1SubscriptionStatus),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        streamId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор открытого соединения.',
            }),
        ),
        subscriptionId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор подписки в формате UUID.',
            }),
        ),
        subscriptionAction: z.optional(zV1SubscriptionAction),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Статус подписки.',
    });

/**
 * Статус подписки на цену последней сделки.
 */
export const zV1LastPriceSubscription = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        subscriptionStatus: z.optional(zV1SubscriptionStatus),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        streamId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор открытого соединения.',
            }),
        ),
        subscriptionId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор подписки в формате `UUID`.',
            }),
        ),
        subscriptionAction: z.optional(zV1SubscriptionAction),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Статус подписки на цену последней сделки.',
    });

/**
 * Статус подписки.
 */
export const zV1OrderBookSubscription = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        depth: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Глубина стакана.',
            }),
        ),
        subscriptionStatus: z.optional(zV1SubscriptionStatus),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        streamId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор открытого соединения.',
            }),
        ),
        subscriptionId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор подписки в формате `UUID`.',
            }),
        ),
        orderBookType: z.optional(zV1OrderBookType),
        subscriptionAction: z.optional(zV1SubscriptionAction),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Статус подписки.',
    });

/**
 * Результат изменения статус подписки на свечи.
 */
export const zV1SubscribeCandlesResponse = z
    .object({
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).',
            }),
        ),
        candlesSubscriptions: z.optional(
            z.array(zV1CandleSubscription).register(z.globalRegistry, {
                description: 'Массив статусов подписки на свечи.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат изменения статус подписки на свечи.',
    });

/**
 * Результат изменения статуса подписки на торговый статус.
 */
export const zV1SubscribeInfoResponse = z
    .object({
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).',
            }),
        ),
        infoSubscriptions: z.optional(
            z.array(zV1InfoSubscription).register(z.globalRegistry, {
                description: 'Массив статусов подписки на торговый статус.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат изменения статуса подписки на торговый статус.',
    });

/**
 * Результат изменения статуса подписки на цену последней сделки.
 */
export const zV1SubscribeLastPriceResponse = z
    .object({
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).',
            }),
        ),
        lastPriceSubscriptions: z.optional(
            z.array(zV1LastPriceSubscription).register(z.globalRegistry, {
                description: 'Массив статусов подписки на цену последней сделки.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат изменения статуса подписки на цену последней сделки.',
    });

/**
 * Результат изменения статуса подписки на стаканы.
 */
export const zV1SubscribeOrderBookResponse = z
    .object({
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).',
            }),
        ),
        orderBookSubscriptions: z.optional(
            z.array(zV1OrderBookSubscription).register(z.globalRegistry, {
                description: 'Массив статусов подписки на стаканы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Результат изменения статуса подписки на стаканы.',
    });

/**
 * Тип TakeProfit-заявки.
 *
 * - TAKE_PROFIT_TYPE_UNSPECIFIED: Значение не указано.
 * - TAKE_PROFIT_TYPE_REGULAR: Обычная заявка, значение по умолчанию.
 * - TAKE_PROFIT_TYPE_TRAILING: Трейлинг-стоп.
 */
export const zV1TakeProfitType = z
    .enum(['TAKE_PROFIT_TYPE_UNSPECIFIED', 'TAKE_PROFIT_TYPE_REGULAR', 'TAKE_PROFIT_TYPE_TRAILING'])
    .register(z.globalRegistry, {
        description:
            'Тип TakeProfit-заявки.\n\n - TAKE_PROFIT_TYPE_UNSPECIFIED: Значение не указано.\n - TAKE_PROFIT_TYPE_REGULAR: Обычная заявка, значение по умолчанию.\n - TAKE_PROFIT_TYPE_TRAILING: Трейлинг-стоп.',
    });

/**
 * Алгоритм исполнения заявки
 *
 * - TIME_IN_FORCE_UNSPECIFIED: Значение не определено см. TIME_IN_FORCE_DAY
 * - TIME_IN_FORCE_DAY: Заявка действует до конца торгового дня. Значение по умолчанию
 * - TIME_IN_FORCE_FILL_AND_KILL: Если в момент выставления возможно исполнение заявки(в т.ч. частичное), заявка будет исполнена или отменена сразу после выставления
 * - TIME_IN_FORCE_FILL_OR_KILL: Если в момент выставления возможно полное исполнение заявки, заявка будет исполнена или отменена сразу после выставления, недоступно для срочного рынка и торговли по выходным
 */
export const zV1TimeInForceType = z
    .enum([
        'TIME_IN_FORCE_UNSPECIFIED',
        'TIME_IN_FORCE_DAY',
        'TIME_IN_FORCE_FILL_AND_KILL',
        'TIME_IN_FORCE_FILL_OR_KILL',
    ])
    .register(z.globalRegistry, {
        description:
            '- TIME_IN_FORCE_UNSPECIFIED: Значение не определено см. TIME_IN_FORCE_DAY\n - TIME_IN_FORCE_DAY: Заявка действует до конца торгового дня. Значение по умолчанию\n - TIME_IN_FORCE_FILL_AND_KILL: Если в момент выставления возможно исполнение заявки(в т.ч. частичное), заявка будет исполнена или отменена сразу после выставления\n - TIME_IN_FORCE_FILL_OR_KILL: Если в момент выставления возможно полное исполнение заявки, заявка будет исполнена или отменена сразу после выставления, недоступно для срочного рынка и торговли по выходным',
    });

/**
 * Заявка
 */
export const zV1OrderStateStreamResponseOrderState = z.object({
    orderId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Биржевой идентификатор заявки.',
        }),
    ),
    orderRequestId: z.optional(
        z.string().register(z.globalRegistry, {
            description:
                'Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов.',
        }),
    ),
    clientCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код клиента на бирже.',
        }),
    ),
    createdAt: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Дата создания заявки.',
        }),
    ),
    executionReportStatus: z.optional(zV1OrderExecutionReportStatus),
    statusInfo: z.optional(zOrderStateStreamResponseStatusCauseInfo),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    classCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Класс-код (секция торгов).',
        }),
    ),
    lotSize: z.optional(
        z.int().register(z.globalRegistry, {
            description: 'Лотность инструмента заявки.',
        }),
    ),
    direction: z.optional(zV1OrderDirection),
    timeInForce: z.optional(zV1TimeInForceType),
    orderType: z.optional(zV1OrderType),
    accountId: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
    ),
    initialOrderPrice: z.optional(zV1MoneyValue),
    orderPrice: z.optional(zV1MoneyValue),
    amount: z.optional(zV1MoneyValue),
    executedOrderPrice: z.optional(zV1MoneyValue),
    currency: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Валюта исполнения.',
        }),
    ),
    lotsRequested: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Запрошено лотов.',
        }),
    ),
    lotsExecuted: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Исполнено лотов.',
        }),
    ),
    lotsLeft: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Число неисполненных лотов по заявке.',
        }),
    ),
    lotsCancelled: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Отмененные лоты.',
        }),
    ),
    marker: z.optional(zOrderStateStreamResponseMarkerType),
    trades: z.optional(
        z.array(zV1OrderTrade).register(z.globalRegistry, {
            description: 'Список сделок.',
        }),
    ),
    completionTime: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description: 'Время исполнения заявки.',
        }),
    ),
    exchange: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Код биржи.',
        }),
    ),
    instrumentUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'UID идентификатор инструмента.',
        }),
    ),
});

/**
 * Информация по заявкам
 */
export const zV1OrderStateStreamResponse = z.object({
    orderState: z.optional(zV1OrderStateStreamResponseOrderState),
    ping: z.optional(zV1Ping),
    subscription: z.optional(zV1SubscriptionResponse),
});

/**
 * Запрос выставления асинхронного торгового поручения.
 */
export const zV1PostOrderAsyncRequest = z
    .object({
        instrumentId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор инструмента, принимает значения Figi или Instrument_uid.',
        }),
        quantity: z.string().register(z.globalRegistry, {
            description: 'Количество лотов.',
        }),
        price: z.optional(zV1Quotation),
        direction: zV1OrderDirection,
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        orderType: zV1OrderType,
        orderId: z.string().register(z.globalRegistry, {
            description:
                'Идентификатор запроса выставления поручения для целей идемпотентности в формате UID. Максимальная длина 36 символов.',
        }),
        timeInForce: z.optional(zV1TimeInForceType),
        priceType: z.optional(zV1PriceType),
        confirmMarginTrade: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Согласие на выставление заявки, которая может привести к непокрытой позиции, по умолчанию false.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос выставления асинхронного торгового поручения.',
    });

/**
 * Запрос выставления торгового поручения.
 */
export const zV1PostOrderRequest = z
    .object({
        quantity: z.string().register(z.globalRegistry, {
            description: 'Количество лотов.',
        }),
        price: z.optional(zV1Quotation),
        direction: zV1OrderDirection,
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        orderType: zV1OrderType,
        orderId: z.string().register(z.globalRegistry, {
            description:
                'Идентификатор запроса выставления поручения для целей идемпотентности в формате UID. Максимальная длина 36 символов.',
        }),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Идентификатор инструмента, принимает значения Figi или Instrument_uid.',
            }),
        ),
        timeInForce: z.optional(zV1TimeInForceType),
        priceType: z.optional(zV1PriceType),
        confirmMarginTrade: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Согласие на выставление заявки, которая может привести к непокрытой позиции, по умолчанию false.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос выставления торгового поручения.',
    });

/**
 * Запрос подписки на поток обезличенных сделок.
 */
export const zV1TradeInstrument = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.',
            }),
        ),
        instrumentId: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    "Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.",
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос подписки на поток обезличенных сделок.',
    });

/**
 * Типы источников сделок.
 *
 * - TRADE_SOURCE_UNSPECIFIED: Тип источника сделки не определён.
 * - TRADE_SOURCE_EXCHANGE: Биржевые сделки.
 * - TRADE_SOURCE_DEALER: Сделки дилера.
 * - TRADE_SOURCE_ALL: Все сделки.
 */
export const zV1TradeSourceType = z
    .enum([
        'TRADE_SOURCE_UNSPECIFIED',
        'TRADE_SOURCE_EXCHANGE',
        'TRADE_SOURCE_DEALER',
        'TRADE_SOURCE_ALL',
    ])
    .register(z.globalRegistry, {
        description:
            'Типы источников сделок.\n\n - TRADE_SOURCE_UNSPECIFIED: Тип источника сделки не определён.\n - TRADE_SOURCE_EXCHANGE: Биржевые сделки.\n - TRADE_SOURCE_DEALER: Сделки дилера.\n - TRADE_SOURCE_ALL: Все сделки.',
    });

/**
 * Запрос обезличенных сделок за последний час.
 */
export const zV1GetLastTradesRequest = z
    .object({
        from: z.iso.datetime().register(z.globalRegistry, {
            description: 'Начало запрашиваемого периода по UTC.',
        }),
        to: z.iso.datetime().register(z.globalRegistry, {
            description: 'Окончание запрашиваемого периода по UTC.',
        }),
        instrumentId: z.optional(z.string()),
        tradeSource: z.optional(zV1TradeSourceType),
    })
    .register(z.globalRegistry, {
        description: 'Запрос обезличенных сделок за последний час.',
    });

/**
 * Изменение статуса подписки на поток обезличенных сделок.
 */
export const zV1SubscribeTradesRequest = z
    .object({
        subscriptionAction: z.optional(zV1SubscriptionAction),
        instruments: z.optional(
            z.array(zV1TradeInstrument).register(z.globalRegistry, {
                description: 'Массив инструментов для подписки на поток обезличенных сделок.',
            }),
        ),
        tradeSource: z.optional(zV1TradeSourceType),
        withOpenInterest: z.optional(z.boolean()),
    })
    .register(z.globalRegistry, {
        description: 'Изменение статуса подписки на поток обезличенных сделок.',
    });

/**
 * Запрос подписки или отписки на определенные биржевые данные.
 */
export const zV1MarketDataRequest = z
    .object({
        subscribeCandlesRequest: z.optional(zV1SubscribeCandlesRequest),
        subscribeOrderBookRequest: z.optional(zV1SubscribeOrderBookRequest),
        subscribeTradesRequest: z.optional(zV1SubscribeTradesRequest),
        subscribeInfoRequest: z.optional(zV1SubscribeInfoRequest),
        subscribeLastPriceRequest: z.optional(zV1SubscribeLastPriceRequest),
        getMySubscriptions: z.optional(
            z.record(z.string(), z.unknown()).register(z.globalRegistry, {
                description:
                    'Запрос активных подписок. Возвращает по одному сообщению на каждый тип активных подписок — `SubscribeLastPriceResponse`, `SubscribeInfoResponse`, `SubscribeTradesResponse`, `SubscribeOrderBookResponse`, `SubscribeCandlesResponse`.',
            }),
        ),
        ping: z.optional(zV1PingRequest),
        pingSettings: z.optional(zV1PingDelaySettings),
    })
    .register(z.globalRegistry, {
        description: 'Запрос подписки или отписки на определенные биржевые данные.',
    });

export const zV1MarketDataServerSideStreamRequest = z.object({
    subscribeCandlesRequest: z.optional(zV1SubscribeCandlesRequest),
    subscribeOrderBookRequest: z.optional(zV1SubscribeOrderBookRequest),
    subscribeTradesRequest: z.optional(zV1SubscribeTradesRequest),
    subscribeInfoRequest: z.optional(zV1SubscribeInfoRequest),
    subscribeLastPriceRequest: z.optional(zV1SubscribeLastPriceRequest),
    pingSettings: z.optional(zV1PingDelaySettings),
});

/**
 * Информация о сделке.
 */
export const zV1Trade = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        direction: z.optional(zContractv1TradeDirection),
        price: z.optional(zV1Quotation),
        quantity: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Количество лотов.',
            }),
        ),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время сделки в часовом поясе UTC по времени биржи.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        tradeSource: z.optional(zV1TradeSourceType),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о сделке.',
    });

/**
 * Обезличенных сделок за последний час.
 */
export const zV1GetLastTradesResponse = z
    .object({
        trades: z.optional(
            z.array(zV1Trade).register(z.globalRegistry, {
                description: 'Массив сделок.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Обезличенных сделок за последний час.',
    });

/**
 * Статус подписки.
 */
export const zV1TradeSubscription = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        subscriptionStatus: z.optional(zV1SubscriptionStatus),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        streamId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор открытого соединения.',
            }),
        ),
        subscriptionId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор подписки в формате UUID.',
            }),
        ),
        withOpenInterest: z.optional(z.boolean()),
        subscriptionAction: z.optional(zV1SubscriptionAction),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Статус подписки.',
    });

/**
 * Результат изменения статуса подписки на поток обезличенных сделок.
 */
export const zV1SubscribeTradesResponse = z
    .object({
        trackingId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).',
            }),
        ),
        tradeSubscriptions: z.optional(
            z.array(zV1TradeSubscription).register(z.globalRegistry, {
                description: 'Массив статусов подписки на поток сделок.',
            }),
        ),
        tradeSource: z.optional(zV1TradeSourceType),
    })
    .register(z.globalRegistry, {
        description: 'Результат изменения статуса подписки на поток обезличенных сделок.',
    });

/**
 * Запрос установки соединения.
 */
export const zV1TradesStreamRequest = z
    .object({
        accounts: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description: 'Идентификаторы счетов.',
            }),
        ),
        pingDelayMs: z.optional(
            z.int().register(z.globalRegistry, {
                description:
                    'Задержка (пинг) сообщений: 5000–180 000 миллисекунд. Значение по умолчанию — 120 000.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос установки соединения.',
    });

/**
 * Информация о торговых поручениях.
 */
export const zV1TradesStreamResponse = z
    .object({
        orderTrades: z.optional(zV1OrderTrades),
        ping: z.optional(zV1Ping),
        subscription: z.optional(zV1SubscriptionResponse),
    })
    .register(z.globalRegistry, {
        description: 'Информация о торговых поручениях.',
    });

export const zV1TradingInterval = z.object({
    type: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Название интервала.',
        }),
    ),
    interval: z.optional(zTradingIntervalTimeInterval),
});

/**
 * Информация о времени торгов.
 */
export const zV1TradingDay = z
    .object({
        date: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата.',
            }),
        ),
        isTradingDay: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак торгового дня на бирже.',
            }),
        ),
        startTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала торгов по UTC.',
            }),
        ),
        endTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время окончания торгов по UTC.',
            }),
        ),
        openingAuctionStartTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала аукциона открытия по UTC.',
            }),
        ),
        closingAuctionEndTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время окончания аукциона закрытия по UTC.',
            }),
        ),
        eveningOpeningAuctionStartTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала аукциона открытия вечерней сессии по UTC.',
            }),
        ),
        eveningStartTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала вечерней сессии по UTC.',
            }),
        ),
        eveningEndTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время окончания вечерней сессии по UTC.',
            }),
        ),
        clearingStartTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала основного клиринга по UTC.',
            }),
        ),
        clearingEndTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время окончания основного клиринга по UTC.',
            }),
        ),
        premarketStartTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала премаркета по UTC.',
            }),
        ),
        premarketEndTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время окончания премаркета по UTC.',
            }),
        ),
        closingAuctionStartTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время начала аукциона закрытия по UTC.',
            }),
        ),
        openingAuctionEndTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время окончания аукциона открытия по UTC.',
            }),
        ),
        intervals: z.optional(
            z.array(zV1TradingInterval).register(z.globalRegistry, {
                description: 'Торговые интервалы.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о времени торгов.',
    });

/**
 * Данные по торговой площадке.
 */
export const zV1TradingSchedule = z
    .object({
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Наименование торговой площадки.',
            }),
        ),
        days: z.optional(
            z.array(zV1TradingDay).register(z.globalRegistry, {
                description: 'Массив с торговыми и неторговыми днями.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Данные по торговой площадке.',
    });

/**
 * Запрос расписания торгов.
 */
export const zV1TradingSchedulesRequest = z
    .object({
        exchange: z.optional(
            z.string().register(z.globalRegistry, {
                description:
                    'Наименование биржи или расчетного календаря. <br/>Если не передается, возвращается информация по всем доступным торговым площадкам.',
            }),
        ),
        from: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Начало периода по UTC.',
            }),
        ),
        to: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Окончание периода по UTC.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос расписания торгов.',
    });

/**
 * Список торговых площадок.
 */
export const zV1TradingSchedulesResponse = z
    .object({
        exchanges: z.optional(
            z.array(zV1TradingSchedule).register(z.globalRegistry, {
                description: 'Список торговых площадок и режимов торгов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список торговых площадок.',
    });

/**
 * Пакет изменения торгового статуса.
 */
export const zV1TradingStatus = z
    .object({
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        tradingStatus: z.optional(zV1SecurityTradingStatus),
        time: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Время изменения торгового статуса по UTC.',
            }),
        ),
        limitOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления лимитной заявки по инструменту.',
            }),
        ),
        marketOrderAvailableFlag: z.optional(
            z.boolean().register(z.globalRegistry, {
                description: 'Признак доступности выставления рыночной заявки по инструменту.',
            }),
        ),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'UID инструмента.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Пакет изменения торгового статуса.',
    });

/**
 * Пакет биржевой информации по подписке.
 */
export const zV1MarketDataResponse = z
    .object({
        subscribeCandlesResponse: z.optional(zV1SubscribeCandlesResponse),
        subscribeOrderBookResponse: z.optional(zV1SubscribeOrderBookResponse),
        subscribeTradesResponse: z.optional(zV1SubscribeTradesResponse),
        subscribeInfoResponse: z.optional(zV1SubscribeInfoResponse),
        candle: z.optional(zV1Candle),
        trade: z.optional(zV1Trade),
        orderbook: z.optional(zV1OrderBook),
        tradingStatus: z.optional(zV1TradingStatus),
        ping: z.optional(zV1Ping),
        subscribeLastPriceResponse: z.optional(zV1SubscribeLastPriceResponse),
        lastPrice: z.optional(zV1LastPrice),
        openInterest: z.optional(zV1OpenInterest),
    })
    .register(z.globalRegistry, {
        description: 'Пакет биржевой информации по подписке.',
    });

/**
 * Статус трейлинг-стопа.
 *
 * - TRAILING_STOP_UNSPECIFIED: Значение не указано.
 * - TRAILING_STOP_ACTIVE: Активный.
 * - TRAILING_STOP_ACTIVATED: Активированный.
 */
export const zV1TrailingStopStatus = z
    .enum(['TRAILING_STOP_UNSPECIFIED', 'TRAILING_STOP_ACTIVE', 'TRAILING_STOP_ACTIVATED'])
    .register(z.globalRegistry, {
        description:
            'Статус трейлинг-стопа.\n\n - TRAILING_STOP_UNSPECIFIED: Значение не указано.\n - TRAILING_STOP_ACTIVE: Активный.\n - TRAILING_STOP_ACTIVATED: Активированный.',
    });

/**
 * Тип параметров значений трейлинг-стопа.
 *
 * - TRAILING_VALUE_UNSPECIFIED: Значение не указано.
 * - TRAILING_VALUE_ABSOLUTE: Абсолютное значение в единицах цены.
 * - TRAILING_VALUE_RELATIVE: Относительное значение в процентах.
 */
export const zV1TrailingValueType = z
    .enum(['TRAILING_VALUE_UNSPECIFIED', 'TRAILING_VALUE_ABSOLUTE', 'TRAILING_VALUE_RELATIVE'])
    .register(z.globalRegistry, {
        description:
            'Тип параметров значений трейлинг-стопа.\n\n - TRAILING_VALUE_UNSPECIFIED: Значение не указано.\n - TRAILING_VALUE_ABSOLUTE: Абсолютное значение в единицах цены.\n - TRAILING_VALUE_RELATIVE: Относительное значение в процентах.',
    });

export const zV1PostStopOrderRequestTrailingData = z.object({
    indent: z.optional(zV1Quotation),
    indentType: z.optional(zV1TrailingValueType),
    spread: z.optional(zV1Quotation),
    spreadType: z.optional(zV1TrailingValueType),
});

/**
 * Запрос выставления стоп-заявки.
 */
export const zV1PostStopOrderRequest = z
    .object({
        quantity: z.string().register(z.globalRegistry, {
            description: 'Количество лотов.',
        }),
        price: z.optional(zV1Quotation),
        stopPrice: z.optional(zV1Quotation),
        direction: zV1StopOrderDirection,
        accountId: z.string().register(z.globalRegistry, {
            description: 'Номер счета.',
        }),
        expirationType: zV1StopOrderExpirationType,
        stopOrderType: zV1StopOrderType,
        expireDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description:
                    'Дата и время окончания действия стоп-заявки по UTC. Для `ExpirationType = GoodTillDate` заполнение обязательно, для `GoodTillCancel` игнорируется.',
            }),
        ),
        instrumentId: z.string().register(z.globalRegistry, {
            description:
                'Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.',
        }),
        exchangeOrderType: z.optional(zV1ExchangeOrderType),
        takeProfitType: z.optional(zV1TakeProfitType),
        trailingData: z.optional(zV1PostStopOrderRequestTrailingData),
        priceType: z.optional(zV1PriceType),
        orderId: z.string().register(z.globalRegistry, {
            description:
                'Идентификатор запроса выставления поручения для целей идемпотентности в формате `UID`. Максимальная длина — 36 символов.',
        }),
        confirmMarginTrade: z.optional(
            z.boolean().register(z.globalRegistry, {
                description:
                    'Согласие на выставление заявки, которая может привести к непокрытой позиции, по умолчанию false.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Запрос выставления стоп-заявки.',
    });

export const zV1StopOrderTrailingData = z.object({
    indent: z.optional(zV1Quotation),
    indentType: z.optional(zV1TrailingValueType),
    spread: z.optional(zV1Quotation),
    spreadType: z.optional(zV1TrailingValueType),
    status: z.optional(zV1TrailingStopStatus),
    price: z.optional(zV1Quotation),
    extr: z.optional(zV1Quotation),
});

/**
 * Информация о стоп-заявке.
 */
export const zV1StopOrder = z
    .object({
        stopOrderId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Уникальный идентификатор стоп-заявки.',
            }),
        ),
        lotsRequested: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Запрошено лотов.',
            }),
        ),
        figi: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'FIGI-идентификатор инструмента.',
            }),
        ),
        direction: z.optional(zV1StopOrderDirection),
        currency: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Валюта стоп-заявки.',
            }),
        ),
        orderType: z.optional(zV1StopOrderType),
        createDate: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время выставления заявки по UTC.',
            }),
        ),
        activationDateTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время конвертации стоп-заявки в биржевую по UTC.',
            }),
        ),
        expirationTime: z.optional(
            z.iso.datetime().register(z.globalRegistry, {
                description: 'Дата и время снятия заявки по UTC.',
            }),
        ),
        price: z.optional(zV1MoneyValue),
        stopPrice: z.optional(zV1MoneyValue),
        instrumentUid: z.optional(
            z.string().register(z.globalRegistry, {
                description: '`instrument_uid`-идентификатор инструмента.',
            }),
        ),
        takeProfitType: z.optional(zV1TakeProfitType),
        trailingData: z.optional(zV1StopOrderTrailingData),
        status: z.optional(zV1StopOrderStatusOption),
        exchangeOrderType: z.optional(zV1ExchangeOrderType),
        exchangeOrderId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор биржевой заявки.',
            }),
        ),
        ticker: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Тикер инструмента.',
            }),
        ),
        classCode: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Класс-код (секция торгов).',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Информация о стоп-заявке.',
    });

/**
 * Список активных стоп-заявок.
 */
export const zV1GetStopOrdersResponse = z
    .object({
        stopOrders: z.optional(
            z.array(zV1StopOrder).register(z.globalRegistry, {
                description: 'Массив стоп-заявок по счету.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Список активных стоп-заявок.',
    });

/**
 * Лимит unary-методов.
 */
export const zV1UnaryLimit = z
    .object({
        limitPerMinute: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Количество unary-запросов в минуту.',
            }),
        ),
        methods: z.optional(
            z.array(z.string()).register(z.globalRegistry, {
                description: 'Названия методов.',
            }),
        ),
        limitPerSecond: z.optional(
            z.int().register(z.globalRegistry, {
                description: 'Количество unary-запросов в секунду.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Лимит unary-методов.',
    });

/**
 * Текущие лимиты пользователя.
 */
export const zV1GetUserTariffResponse = z
    .object({
        unaryLimits: z.optional(
            z.array(zV1UnaryLimit).register(z.globalRegistry, {
                description: 'Массив лимитов пользователя по unary-запросам.',
            }),
        ),
        streamLimits: z.optional(
            z.array(zV1StreamLimit).register(z.globalRegistry, {
                description: 'Массив лимитов пользователей для stream-соединений.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Текущие лимиты пользователя.',
    });

export const zV1VirtualPortfolioPosition = z.object({
    positionUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор позиции.',
        }),
    ),
    instrumentUid: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Уникальный идентификатор инструмента.',
        }),
    ),
    figi: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'FIGI-идентификатор инструмента.',
        }),
    ),
    instrumentType: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тип инструмента.',
        }),
    ),
    quantity: z.optional(zV1Quotation),
    averagePositionPrice: z.optional(zV1MoneyValue),
    expectedYield: z.optional(zV1Quotation),
    expectedYieldFifo: z.optional(zV1Quotation),
    expireDate: z.optional(
        z.iso.datetime().register(z.globalRegistry, {
            description:
                'Дата, до которой нужно продать виртуальные бумаги. После этой даты виртуальная позиция «сгораетт».',
        }),
    ),
    currentPrice: z.optional(zV1MoneyValue),
    averagePositionPriceFifo: z.optional(zV1MoneyValue),
    dailyYield: z.optional(zV1MoneyValue),
    ticker: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Тикер инструмента.',
        }),
    ),
    classCode: z.optional(
        z.string().register(z.globalRegistry, {
            description: 'Класс-код (секция торгов).',
        }),
    ),
});

/**
 * Текущий портфель по счету.
 */
export const zV1PortfolioResponse = z
    .object({
        totalAmountShares: z.optional(zV1MoneyValue),
        totalAmountBonds: z.optional(zV1MoneyValue),
        totalAmountEtf: z.optional(zV1MoneyValue),
        totalAmountCurrencies: z.optional(zV1MoneyValue),
        totalAmountFutures: z.optional(zV1MoneyValue),
        expectedYield: z.optional(zV1Quotation),
        positions: z.optional(
            z.array(zV1PortfolioPosition).register(z.globalRegistry, {
                description: 'Список позиций портфеля.',
            }),
        ),
        accountId: z.optional(
            z.string().register(z.globalRegistry, {
                description: 'Идентификатор счета пользователя.',
            }),
        ),
        totalAmountOptions: z.optional(zV1MoneyValue),
        totalAmountSp: z.optional(zV1MoneyValue),
        totalAmountPortfolio: z.optional(zV1MoneyValue),
        virtualPositions: z.optional(
            z.array(zV1VirtualPortfolioPosition).register(z.globalRegistry, {
                description: 'Массив виртуальных позиций портфеля.',
            }),
        ),
        dailyYield: z.optional(zV1MoneyValue),
        dailyYieldRelative: z.optional(zV1Quotation),
    })
    .register(z.globalRegistry, {
        description: 'Текущий портфель по счету.',
    });

/**
 * Информация по позициям и доходностям портфелей.
 */
export const zV1PortfolioStreamResponse = z
    .object({
        subscriptions: z.optional(zV1PortfolioSubscriptionResult),
        portfolio: z.optional(zV1PortfolioResponse),
        ping: z.optional(zV1Ping),
    })
    .register(z.globalRegistry, {
        description: 'Информация по позициям и доходностям портфелей.',
    });

/**
 * Запрос доступного остатка для вывода.
 */
export const zV1WithdrawLimitsRequest = z
    .object({
        accountId: z.string().register(z.globalRegistry, {
            description: 'Идентификатор счета пользователя.',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Запрос доступного остатка для вывода.',
    });

/**
 * Доступный остаток для вывода.
 */
export const zV1WithdrawLimitsResponse = z
    .object({
        money: z.optional(
            z.array(zV1MoneyValue).register(z.globalRegistry, {
                description: 'Массив валютных позиций портфеля.',
            }),
        ),
        blocked: z.optional(
            z.array(zV1MoneyValue).register(z.globalRegistry, {
                description: 'Массив заблокированных валютных позиций портфеля.',
            }),
        ),
        blockedGuarantee: z.optional(
            z.array(zV1MoneyValue).register(z.globalRegistry, {
                description: 'Заблокировано под гарантийное обеспечение фьючерсов.',
            }),
        ),
    })
    .register(z.globalRegistry, {
        description: 'Доступный остаток для вывода.',
    });

/**
 * Stream result of v1MarketDataResponse
 */
export const zStreamResultOfV1MarketDataResponse = z.object({
    result: z.optional(zV1MarketDataResponse),
    error: z.optional(zRpcStatus),
});

/**
 * Stream result of v1PortfolioStreamResponse
 */
export const zStreamResultOfV1PortfolioStreamResponse = z.object({
    result: z.optional(zV1PortfolioStreamResponse),
    error: z.optional(zRpcStatus),
});

/**
 * Stream result of v1PositionsStreamResponse
 */
export const zStreamResultOfV1PositionsStreamResponse = z.object({
    result: z.optional(zV1PositionsStreamResponse),
    error: z.optional(zRpcStatus),
});

/**
 * Stream result of v1OrderStateStreamResponse
 */
export const zStreamResultOfV1OrderStateStreamResponse = z.object({
    result: z.optional(zV1OrderStateStreamResponse),
    error: z.optional(zRpcStatus),
});

/**
 * Stream result of v1TradesStreamResponse
 */
export const zStreamResultOfV1TradesStreamResponse = z.object({
    result: z.optional(zV1TradesStreamResponse),
    error: z.optional(zRpcStatus),
});

/**
 * Данные об ошибке
 */
export const zErrorResponse = z
    .object({
        code: z.int().register(z.globalRegistry, {
            description: 'Уникальный идентификатор ошибки',
        }),
        message: z.string().register(z.globalRegistry, {
            description: 'Пользовательское сообщение об ошибке',
        }),
        description: z.int().register(z.globalRegistry, {
            description: 'Код ошибки',
        }),
    })
    .register(z.globalRegistry, {
        description: 'Данные об ошибке',
    });

export const zInstrumentsServiceBondByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceBondByResponse = zV1BondResponse;

export const zInstrumentsServiceBondsData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceBondsResponse = zV1BondsResponse;

export const zInstrumentsServiceCreateFavoriteGroupData = z.object({
    body: zV1CreateFavoriteGroupRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceCreateFavoriteGroupResponse = zV1CreateFavoriteGroupResponse;

export const zInstrumentsServiceCurrenciesData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceCurrenciesResponse = zV1CurrenciesResponse;

export const zInstrumentsServiceCurrencyByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceCurrencyByResponse = zV1CurrencyResponse;

export const zInstrumentsServiceDeleteFavoriteGroupData = z.object({
    body: zV1DeleteFavoriteGroupRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceDeleteFavoriteGroupResponse = zV1DeleteFavoriteGroupResponse;

export const zInstrumentsServiceEditFavoritesData = z.object({
    body: zV1EditFavoritesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceEditFavoritesResponse = zV1EditFavoritesResponse;

export const zInstrumentsServiceEtfByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceEtfByResponse = zV1EtfResponse;

export const zInstrumentsServiceEtfsData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceEtfsResponse = zV1EtfsResponse;

export const zInstrumentsServiceFindInstrumentData = z.object({
    body: zV1FindInstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceFindInstrumentResponse = zV1FindInstrumentResponse;

export const zInstrumentsServiceFutureByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceFutureByResponse = zV1FutureResponse;

export const zInstrumentsServiceFuturesData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceFuturesResponse = zV1FuturesResponse;

export const zInstrumentsServiceGetAccruedInterestsData = z.object({
    body: zV1GetAccruedInterestsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetAccruedInterestsResponse = zV1GetAccruedInterestsResponse;

export const zInstrumentsServiceGetAssetByData = z.object({
    body: zV1AssetRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetAssetByResponse = zV1AssetResponse;

export const zInstrumentsServiceGetAssetFundamentalsData = z.object({
    body: zV1GetAssetFundamentalsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetAssetFundamentalsResponse = zV1GetAssetFundamentalsResponse;

export const zInstrumentsServiceGetAssetReportsData = z.object({
    body: zV1GetAssetReportsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetAssetReportsResponse = zV1GetAssetReportsResponse;

export const zInstrumentsServiceGetAssetsData = z.object({
    body: zV1AssetsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetAssetsResponse = zV1AssetsResponse;

export const zInstrumentsServiceGetBondCouponsData = z.object({
    body: zV1GetBondCouponsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetBondCouponsResponse = zV1GetBondCouponsResponse;

export const zInstrumentsServiceGetBondEventsData = z.object({
    body: zV1GetBondEventsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetBondEventsResponse = zV1GetBondEventsResponse;

export const zInstrumentsServiceGetBrandByData = z.object({
    body: zV1GetBrandRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetBrandByResponse = zV1Brand;

export const zInstrumentsServiceGetBrandsData = z.object({
    body: zV1GetBrandsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetBrandsResponse = zV1GetBrandsResponse;

export const zInstrumentsServiceGetConsensusForecastsData = z.object({
    body: zV1GetConsensusForecastsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetConsensusForecastsResponse = zV1GetConsensusForecastsResponse;

export const zInstrumentsServiceGetCountriesData = z.object({
    body: zV1GetCountriesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetCountriesResponse = zV1GetCountriesResponse;

export const zInstrumentsServiceGetDividendsData = z.object({
    body: zV1GetDividendsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetDividendsResponse = zV1GetDividendsResponse;

export const zInstrumentsServiceGetFavoriteGroupsData = z.object({
    body: zV1GetFavoriteGroupsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetFavoriteGroupsResponse = zV1GetFavoriteGroupsResponse;

export const zInstrumentsServiceGetFavoritesData = z.object({
    body: zV1GetFavoritesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetFavoritesResponse = zV1GetFavoritesResponse;

export const zInstrumentsServiceGetForecastByData = z.object({
    body: zV1GetForecastRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetForecastByResponse = zV1GetForecastResponse;

export const zInstrumentsServiceGetFuturesMarginData = z.object({
    body: zV1GetFuturesMarginRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetFuturesMarginResponse = zV1GetFuturesMarginResponse;

export const zInstrumentsServiceGetInsiderDealsData = z.object({
    body: zV1GetInsiderDealsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetInsiderDealsResponse = zV1GetInsiderDealsResponse;

export const zInstrumentsServiceGetInstrumentByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetInstrumentByResponse = zV1InstrumentResponse;

export const zInstrumentsServiceGetRiskRatesData = z.object({
    body: zV1RiskRatesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceGetRiskRatesResponse = zV1RiskRatesResponse;

export const zInstrumentsServiceIndicativesData = z.object({
    body: zV1IndicativesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceIndicativesResponse = zV1IndicativesResponse;

export const zInstrumentsServiceOptionByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceOptionByResponse = zV1OptionResponse;

export const zInstrumentsServiceOptionsData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceOptionsResponse = zV1OptionsResponse;

export const zInstrumentsServiceOptionsByData = z.object({
    body: zV1FilterOptionsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceOptionsByResponse = zV1OptionsResponse;

export const zInstrumentsServiceShareByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceShareByResponse = zV1ShareResponse;

export const zInstrumentsServiceSharesData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceSharesResponse = zV1SharesResponse;

export const zInstrumentsServiceStructuredNoteByData = z.object({
    body: zV1InstrumentRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceStructuredNoteByResponse = zV1StructuredNoteResponse;

export const zInstrumentsServiceStructuredNotesData = z.object({
    body: zV1InstrumentsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceStructuredNotesResponse = zV1StructuredNotesResponse;

export const zInstrumentsServiceTradingSchedulesData = z.object({
    body: zV1TradingSchedulesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zInstrumentsServiceTradingSchedulesResponse = zV1TradingSchedulesResponse;

export const zMarketDataServiceGetCandlesData = z.object({
    body: zV1GetCandlesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetCandlesResponse = zV1GetCandlesResponse;

export const zMarketDataServiceGetClosePricesData = z.object({
    body: zV1GetClosePricesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetClosePricesResponse = zV1GetClosePricesResponse;

export const zMarketDataServiceGetLastPricesData = z.object({
    body: zV1GetLastPricesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetLastPricesResponse = zV1GetLastPricesResponse;

export const zMarketDataServiceGetLastTradesData = z.object({
    body: zV1GetLastTradesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetLastTradesResponse = zV1GetLastTradesResponse;

export const zMarketDataServiceGetMarketValuesData = z.object({
    body: zV1GetMarketValuesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetMarketValuesResponse = zV1GetMarketValuesResponse;

export const zMarketDataServiceGetOrderBookData = z.object({
    body: zV1GetOrderBookRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetOrderBookResponse = zV1GetOrderBookResponse;

export const zMarketDataServiceGetTechAnalysisData = z.object({
    body: zV1GetTechAnalysisRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetTechAnalysisResponse = zV1GetTechAnalysisResponse;

export const zMarketDataServiceGetTradingStatusData = z.object({
    body: zV1GetTradingStatusRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetTradingStatusResponse = zV1GetTradingStatusResponse;

export const zMarketDataServiceGetTradingStatusesData = z.object({
    body: zV1GetTradingStatusesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zMarketDataServiceGetTradingStatusesResponse = zV1GetTradingStatusesResponse;

export const zMarketDataStreamServiceMarketDataServerSideStreamData = z.object({
    body: zV1MarketDataServerSideStreamRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.(streaming responses)
 */
export const zMarketDataStreamServiceMarketDataServerSideStreamResponse =
    zStreamResultOfV1MarketDataResponse;

export const zMarketDataStreamServiceMarketDataStreamData = z.object({
    body: zV1MarketDataRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.(streaming responses)
 */
export const zMarketDataStreamServiceMarketDataStreamResponse = zStreamResultOfV1MarketDataResponse;

export const zOperationsServiceGetBrokerReportData = z.object({
    body: zV1BrokerReportRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetBrokerReportResponse = zV1BrokerReportResponse;

export const zOperationsServiceGetDividendsForeignIssuerData = z.object({
    body: zV1GetDividendsForeignIssuerRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetDividendsForeignIssuerResponse =
    zV1GetDividendsForeignIssuerResponse;

export const zOperationsServiceGetOperationsData = z.object({
    body: zV1OperationsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetOperationsResponse = zV1OperationsResponse;

export const zOperationsServiceGetOperationsByCursorData = z.object({
    body: zV1GetOperationsByCursorRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetOperationsByCursorResponse = zV1GetOperationsByCursorResponse;

export const zOperationsServiceGetPortfolioData = z.object({
    body: zV1PortfolioRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetPortfolioResponse = zV1PortfolioResponse;

export const zOperationsServiceGetPositionsData = z.object({
    body: zV1PositionsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetPositionsResponse = zV1PositionsResponse;

export const zOperationsServiceGetWithdrawLimitsData = z.object({
    body: zV1WithdrawLimitsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOperationsServiceGetWithdrawLimitsResponse = zV1WithdrawLimitsResponse;

export const zOperationsStreamServicePortfolioStreamData = z.object({
    body: zV1PortfolioStreamRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.(streaming responses)
 */
export const zOperationsStreamServicePortfolioStreamResponse =
    zStreamResultOfV1PortfolioStreamResponse;

export const zOperationsStreamServicePositionsStreamData = z.object({
    body: zV1PositionsStreamRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.(streaming responses)
 */
export const zOperationsStreamServicePositionsStreamResponse =
    zStreamResultOfV1PositionsStreamResponse;

export const zOrdersServiceCancelOrderData = z.object({
    body: zV1CancelOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServiceCancelOrderResponse = zV1CancelOrderResponse;

export const zOrdersServiceGetMaxLotsData = z.object({
    body: zV1GetMaxLotsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServiceGetMaxLotsResponse = zV1GetMaxLotsResponse;

export const zOrdersServiceGetOrderPriceData = z.object({
    body: zV1GetOrderPriceRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServiceGetOrderPriceResponse = zV1GetOrderPriceResponse;

export const zOrdersServiceGetOrderStateData = z.object({
    body: zV1GetOrderStateRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServiceGetOrderStateResponse = zContractv1OrderState;

export const zOrdersServiceGetOrdersData = z.object({
    body: zV1GetOrdersRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServiceGetOrdersResponse = zV1GetOrdersResponse;

export const zOrdersServicePostOrderData = z.object({
    body: zV1PostOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServicePostOrderResponse = zV1PostOrderResponse;

export const zOrdersServicePostOrderAsyncData = z.object({
    body: zV1PostOrderAsyncRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServicePostOrderAsyncResponse = zV1PostOrderAsyncResponse;

export const zOrdersServiceReplaceOrderData = z.object({
    body: zV1ReplaceOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zOrdersServiceReplaceOrderResponse = zV1PostOrderResponse;

export const zOrdersStreamServiceOrderStateStreamData = z.object({
    body: zV1OrderStateStreamRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.(streaming responses)
 */
export const zOrdersStreamServiceOrderStateStreamResponse =
    zStreamResultOfV1OrderStateStreamResponse;

export const zOrdersStreamServiceTradesStreamData = z.object({
    body: zV1TradesStreamRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.(streaming responses)
 */
export const zOrdersStreamServiceTradesStreamResponse = zStreamResultOfV1TradesStreamResponse;

export const zSandboxServiceCancelSandboxOrderData = z.object({
    body: zV1CancelOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceCancelSandboxOrderResponse = zV1CancelOrderResponse;

export const zSandboxServiceCancelSandboxStopOrderData = z.object({
    body: zV1CancelStopOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceCancelSandboxStopOrderResponse = zV1CancelStopOrderResponse;

export const zSandboxServiceCloseSandboxAccountData = z.object({
    body: zV1CloseSandboxAccountRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceCloseSandboxAccountResponse = zV1CloseSandboxAccountResponse;

export const zSandboxServiceGetSandboxAccountsData = z.object({
    body: zV1GetAccountsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxAccountsResponse = zV1GetAccountsResponse;

export const zSandboxServiceGetSandboxMaxLotsData = z.object({
    body: zV1GetMaxLotsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxMaxLotsResponse = zV1GetMaxLotsResponse;

export const zSandboxServiceGetSandboxOperationsData = z.object({
    body: zV1OperationsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxOperationsResponse = zV1OperationsResponse;

export const zSandboxServiceGetSandboxOperationsByCursorData = z.object({
    body: zV1GetOperationsByCursorRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxOperationsByCursorResponse = zV1GetOperationsByCursorResponse;

export const zSandboxServiceGetSandboxOrderPriceData = z.object({
    body: zV1GetOrderPriceRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxOrderPriceResponse = zV1GetOrderPriceResponse;

export const zSandboxServiceGetSandboxOrderStateData = z.object({
    body: zV1GetOrderStateRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxOrderStateResponse = zContractv1OrderState;

export const zSandboxServiceGetSandboxOrdersData = z.object({
    body: zV1GetOrdersRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxOrdersResponse = zV1GetOrdersResponse;

export const zSandboxServiceGetSandboxPortfolioData = z.object({
    body: zV1PortfolioRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxPortfolioResponse = zV1PortfolioResponse;

export const zSandboxServiceGetSandboxPositionsData = z.object({
    body: zV1PositionsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxPositionsResponse = zV1PositionsResponse;

export const zSandboxServiceGetSandboxStopOrdersData = z.object({
    body: zV1GetStopOrdersRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxStopOrdersResponse = zV1GetStopOrdersResponse;

export const zSandboxServiceGetSandboxWithdrawLimitsData = z.object({
    body: zV1WithdrawLimitsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceGetSandboxWithdrawLimitsResponse = zV1WithdrawLimitsResponse;

export const zSandboxServiceOpenSandboxAccountData = z.object({
    body: zV1OpenSandboxAccountRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceOpenSandboxAccountResponse = zV1OpenSandboxAccountResponse;

export const zSandboxServicePostSandboxOrderData = z.object({
    body: zV1PostOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServicePostSandboxOrderResponse = zV1PostOrderResponse;

export const zSandboxServicePostSandboxOrderAsyncData = z.object({
    body: zV1PostOrderAsyncRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServicePostSandboxOrderAsyncResponse = zV1PostOrderAsyncResponse;

export const zSandboxServicePostSandboxStopOrderData = z.object({
    body: zV1PostStopOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServicePostSandboxStopOrderResponse = zV1PostStopOrderResponse;

export const zSandboxServiceReplaceSandboxOrderData = z.object({
    body: zV1ReplaceOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceReplaceSandboxOrderResponse = zV1PostOrderResponse;

export const zSandboxServiceSandboxPayInData = z.object({
    body: zV1SandboxPayInRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSandboxServiceSandboxPayInResponse = zV1SandboxPayInResponse;

export const zSignalServiceGetSignalsData = z.object({
    body: zV1GetSignalsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSignalServiceGetSignalsResponse = zV1GetSignalsResponse;

export const zSignalServiceGetStrategiesData = z.object({
    body: zV1GetStrategiesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zSignalServiceGetStrategiesResponse = zV1GetStrategiesResponse;

export const zStopOrdersServiceCancelStopOrderData = z.object({
    body: zV1CancelStopOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zStopOrdersServiceCancelStopOrderResponse = zV1CancelStopOrderResponse;

export const zStopOrdersServiceGetStopOrdersData = z.object({
    body: zV1GetStopOrdersRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zStopOrdersServiceGetStopOrdersResponse = zV1GetStopOrdersResponse;

export const zStopOrdersServicePostStopOrderData = z.object({
    body: zV1PostStopOrderRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zStopOrdersServicePostStopOrderResponse = zV1PostStopOrderResponse;

export const zUsersServiceCurrencyTransferData = z.object({
    body: zV1CurrencyTransferRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zUsersServiceCurrencyTransferResponse = zV1CurrencyTransferResponse;

export const zUsersServiceGetAccountsData = z.object({
    body: zV1GetAccountsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zUsersServiceGetAccountsResponse = zV1GetAccountsResponse;

export const zUsersServiceGetBankAccountsData = z.object({
    body: zV1GetBankAccountsRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zUsersServiceGetBankAccountsResponse = zV1GetBankAccountsResponse;

export const zUsersServiceGetInfoData = z.object({
    body: zV1GetInfoRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zUsersServiceGetInfoResponse = zV1GetInfoResponse;

export const zUsersServiceGetMarginAttributesData = z.object({
    body: zV1GetMarginAttributesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zUsersServiceGetMarginAttributesResponse = zV1GetMarginAttributesResponse;

export const zUsersServiceGetUserTariffData = z.object({
    body: zV1GetUserTariffRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
});

/**
 * A successful response.
 */
export const zUsersServiceGetUserTariffResponse = zV1GetUserTariffResponse;
